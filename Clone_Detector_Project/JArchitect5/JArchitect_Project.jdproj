<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<NDepend AppName="JArchitect_Project" Platform="DotNet">
  <OutputDir KeepXmlFiles="True">E:\SQ_proj\trunk\Clone_Detector_Project\JArchitect5\JArchitectOut</OutputDir>
  <Assemblies>
    <Name>E:\SQ_proj\trunk\Clone_Detector_Project\InputProjects\Cricket-master\.project</Name>
  </Assemblies>
  <FrameworkAssemblies />
  <Dirs>
    <Dir>C:\Program Files\Java\jre1.8.0_112\lib</Dir>
    <Dir>E:\SQ_proj\trunk\Clone_Detector_Project\InputProjects\Cricket-master</Dir>
  </Dirs>
  <Report Flags="257024" Kind="0" SectionsEnabled="45055" XslPath="" />
  <BuildComparisonSetting BuildFileToCompareWith="" BuildMode="MostRecentAnalysisResultAvailable" FocusOnRecentRulesViolations="False" NDaysAgo="1" ProjectFileToCompareWith="" ProjectMode="DontCompare" />
  <BaselineInUISetting BuildFileToCompareWith="" BuildMode="MostRecentAnalysisResultAvailable" FocusOnRecentRulesViolations="False" NDaysAgo="1" ProjectFileToCompareWith="" ProjectMode="DontCompare" />
  <CoverageFiles CoverageDir="" UncoverableAttribute="" />
  <Plugins CHECKSTYLE="false" FINDBUGS="false" PMD="false" />
  <TrendMetrics CustomDir="" LogLabel="2" LogRecurrence="3" UseCustomDir="False" UseCustomLog="False">
    <Chart Name="Lines of Code" ShowInReport="True">
      <Serie ChartType="Line" Color="#FF00BFFF" MetricName="# Lines of Code" MetricUnit="Loc" ScaleExp="0" />
      <Serie ChartType="Area" Color="#FF32CD32" MetricName="# Lines of Code Covered" MetricUnit="Loc" ScaleExp="0" />
      <Serie ChartType="Area" Color="#FFA9A9A9" MetricName="# Lines of Code (NotMyCode)" MetricUnit="Loc" ScaleExp="0" />
      <Serie ChartType="Line" Color="#FF008000" MetricName="# Lines of Comments" MetricUnit="Lines" ScaleExp="0" />
    </Chart>
    <Chart Name="Rules Violated" ShowInReport="True">
      <Serie ChartType="Line" Color="#FF66CDAA" MetricName="# Rules" MetricUnit="Rules" ScaleExp="0" />
      <Serie ChartType="Area" Color="#FFFF8C00" MetricName="# Rules Violated" MetricUnit="Rules" ScaleExp="0" />
      <Serie ChartType="Area" Color="#FFFF0000" MetricName="# Critical Rules Violated" MetricUnit="Rules" ScaleExp="0" />
    </Chart>
    <Chart Name="Rules Violations" ShowInReport="True">
      <Serie ChartType="Area" Color="#FFFF8C00" MetricName="# Rules Violations" MetricUnit="Violations" ScaleExp="0" />
      <Serie ChartType="Area" Color="#FFFF0000" MetricName="# Critical Rules Violations" MetricUnit="Violations" ScaleExp="0" />
    </Chart>
    <Chart Name="Percentage Coverage by Tests" ShowInReport="True">
      <Serie ChartType="Area" Color="#FF32CD32" MetricName="Percentage Code Coverage" MetricUnit="%" ScaleExp="0" />
    </Chart>
    <Chart Name="Max" ShowInReport="True">
      <Serie ChartType="Line" Color="#FFFF0000" MetricName="Max BC Cyclomatic Complexity for Methods" MetricUnit="Paths" ScaleExp="0" />
      <Serie ChartType="Line" Color="#FF0000FF" MetricName="Max # Lines of Code for Methods (JustMyCode)" MetricUnit="LoC" ScaleExp="0" />
      <Serie ChartType="Line" Color="#FF32CD32" MetricName="Max # of Methods for Types" MetricUnit="Methods" ScaleExp="0" />
      <Serie ChartType="Line" Color="#FFFFD700" MetricName="Max BC Nesting Depth for Methods" MetricUnit="Scopes" ScaleExp="0" />
    </Chart>
    <Chart Name="Average" ShowInReport="True">
      <Serie ChartType="Line" Color="#FFFF0000" MetricName="Average BC Cyclomatic Complexity for Methods" MetricUnit="Paths" ScaleExp="0" />
      <Serie ChartType="Line" Color="#FF0000FF" MetricName="Average # Lines of Code for Methods" MetricUnit="LoC" ScaleExp="0" />
      <Serie ChartType="Line" Color="#FF32CD32" MetricName="Average # Methods for Types" MetricUnit="Methods" ScaleExp="0" />
      <Serie ChartType="Line" Color="#FFFFD700" MetricName="Average BC Nesting Depth for Methods" MetricUnit="Scopes" ScaleExp="0" />
    </Chart>
    <Chart Name="Third-Party Usage" ShowInReport="True">
      <Serie ChartType="Line" Color="#FF0000FF" MetricName="# Third-Party Types Used" MetricUnit="Types" ScaleExp="0" />
      <Serie ChartType="Line" Color="#FFFF0000" MetricName="# Third-Party Methods Used" MetricUnit="Methods" ScaleExp="0" />
      <Serie ChartType="Line" Color="#FF646464" MetricName="# Third-Party Projects Used" MetricUnit="Projects" ScaleExp="1" />
      <Serie ChartType="Line" Color="#FF32CD32" MetricName="# Third-Party Packages Used" MetricUnit="PACKAGES" ScaleExp="1" />
      <Serie ChartType="Line" Color="#FFFFD700" MetricName="# Third-Party Fields Used" MetricUnit="Fields" ScaleExp="1" />
    </Chart>
  </TrendMetrics>
  <HistoricAnalysisResult CustomDir="" PersistRecurrence="3" UseCustomDir="False" />
  <SourceFileRebasing FromPath="" ToPath="" />
  <PathVariables />
  <RuleFiles />
  <ProjectRules AreActive="True" /><Queries>
    <Group Active="False" Name="Code Quality" ShownInReport="False">
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="True">// &lt;Name&gt;Types too big - critical&lt;/Name&gt;
warnif count &gt; 0 from t in JustMyCode.Types where 
   t.NbLinesOfCode &gt; 500 ||
   t.NbBCInstructions &gt; 3000
   orderby t.NbLinesOfCode descending
select new { t, t.NbLinesOfCode, t.NbBCInstructions,
                t.Methods, t.Fields }

// Types where NbLinesOfCode &gt; 500 are extremely complex 
// and should be split in a smaller group of types. 
// See the definition of the NbLinesOfCode metric here 
// http://www.jarchitect.com/Metrics.aspx#NbLinesOfCode

// In average, a line of code is compiled to around
// 6 BC instructions. This is why the code metric
// NbBCInstructions is used here, in case the 
// code metric NbLinesOfCode is un-available because
// of missing code source files.
// See the definition of the NbBCInstructions metric here 
// http://www.jarchitect.com/Metrics.aspx#NbBCInstructions

</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="True">// &lt;Name&gt;Methods too complex - critical&lt;/Name&gt;
warnif count &gt; 0 from m in JustMyCode.Methods where 
  m.BCCyclomaticComplexity &gt; 40 &amp;&amp; 
  m.BCNestingDepth &gt; 5
  orderby m.BCCyclomaticComplexity descending,
          m.BCNestingDepth descending
select new { m, m.BCCyclomaticComplexity, m.BCNestingDepth }

// Methods with BCCyclomaticComplexity &gt; 40 and BCNestingDepth  &gt; 4
// are really too complex and should be split 
// in smaller methods, or even types.
// See the definition of the BCCyclomaticComplexity metric here 
// http://www.jarchitect.com/Metrics.aspx#ILCC
// See the definition of the BCNestingDepth metric here 
// http://www.jarchitect.com/Metrics.aspx#BCNestingDepth</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="True">// &lt;Name&gt;Methods with too many parameters - critical&lt;/Name&gt;
warnif count &gt; 0 from m in JustMyCode.Methods where 
  m.NbParameters &gt; 8
  orderby m.NbParameters descending
select new { m, m.NbParameters }

// Methods with more than 8 parameters might be painful to call 
// and might degrade performance. You should prefer using 
// additional properties/fields to the declaring type to 
// handle numerous states. Another alternative is to provide 
// a class or structure dedicated to handle arguments passing 
//  See the definition of the NbParameters metric here 
// http://www.jarchitect.com/Metrics.aspx#NbParameters
</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Quick summary of methods to refactor&lt;/Name&gt;
warnif count &gt; 0 from m in JustMyCode.Methods where 
                                    // Code Metrics' definitions
  m.NbLinesOfCode &gt; 30 ||           // http://www.jarchitect.com/Metrics.aspx#NbLinesOfCode
  m.NbBCInstructions &gt; 200 ||       // http://www.jarchitect.com/Metrics.aspx#NbBCInstructions
  m.CyclomaticComplexity &gt; 20 ||    // http://www.jarchitect.com/Metrics.aspx#CC
  m.BCCyclomaticComplexity &gt; 50 ||  // http://www.jarchitect.com/Metrics.aspx#ILCC
  m.BCNestingDepth &gt; 5 ||           // http://www.jarchitect.com/Metrics.aspx#BCNestingDepth
  m.NbParameters &gt; 5 ||             // http://www.jarchitect.com/Metrics.aspx#NbParameters
  m.NbVariables &gt; 8 ||              // http://www.jarchitect.com/Metrics.aspx#NbVariables
  m.NbOverloads &gt; 6                 // http://www.jarchitect.com/Metrics.aspx#NbOverloads

select new { m, m.NbLinesOfCode, m.NbBCInstructions, m.CyclomaticComplexity, 
             m.BCCyclomaticComplexity, m.BCNestingDepth, 
             m.NbParameters, m.NbVariables, m.NbOverloads } </Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Methods too big&lt;/Name&gt;
warnif count &gt; 0 from m in JustMyCode.Methods where 
   m.NbLinesOfCode &gt; 30 ||
   m.NbBCInstructions &gt; 200
   orderby m.NbLinesOfCode descending,
           m.NbBCInstructions descending
select new { m, m.NbLinesOfCode, m.NbBCInstructions }

// Methods where NbLinesOfCode &gt; 30 or NbBCInstructions &gt; 200
// are extremely complex and should be split in smaller methods.
// See the definition of the NbLinesOfCode metric here 
// http://www.jarchitect.com/Metrics.aspx#NbLinesOfCode</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Methods too complex&lt;/Name&gt;
warnif count &gt; 0 from m in JustMyCode.Methods where 
  m.CyclomaticComplexity &gt; 20 ||
  m.BCCyclomaticComplexity &gt; 40 ||
  m.BCNestingDepth &gt; 5
  orderby m.CyclomaticComplexity descending,
          m.BCCyclomaticComplexity descending,
          m.BCNestingDepth descending
select new { m, m.CyclomaticComplexity, 
                m.BCCyclomaticComplexity,
                m.BCNestingDepth  }

// Methods where CyclomaticComplexity &gt; 20 
// or BCCyclomaticComplexity &gt; 40
// or BCNestingDepth &gt; 4
// are hard to understand and maintain
// and should be split in smaller methods.
// See the definition of the complexity metrics here:
// http://www.jarchitect.com/Metrics.aspx#CC
// http://www.jarchitect.com/Metrics.aspx#ILCC
// http://www.jarchitect.com/Metrics.aspx#BCNestingDepth</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Methods potentially poorly commented&lt;/Name&gt;
warnif count &gt; 0 from m in JustMyCode.Methods where 
  m.PercentageComment &lt; 20 &amp;&amp; 
  m.NbLinesOfCode &gt; 20  
  orderby m.PercentageComment ascending
select new { m, m.PercentageComment, m.NbLinesOfCode, m.NbLinesOfComment }

// Methods where %Comment &lt; 20 and that have 
// at least 20 lines of code might need to be more commented.
// See the definition of the Comments metric here 
// http://www.jarchitect.com/Metrics.aspx#PercentageComment
// http://www.jarchitect.com/Metrics.aspx#NbLinesOfComment </Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Methods with too many parameters&lt;/Name&gt;
warnif count &gt; 0 from m in JustMyCode.Methods where 
  m.NbParameters &gt; 5 
  orderby m.NbParameters descending
select new { m, m.NbParameters }

// Methods where NbParameters &gt; 5 might be painful to call 
// and might degrade performance. You should prefer using 
// additional properties/fields to the declaring type to 
// handle numerous states. Another alternative is to provide 
// a class or structure dedicated to handle arguments passing 
// See the definition of the NbParameters metric here 
// http://www.jarchitect.com/Metrics.aspx#NbParameters</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Methods with too many local variables&lt;/Name&gt;
warnif count &gt; 0 from m in JustMyCode.Methods where 
  m.NbVariables &gt; 15 
  orderby m.NbVariables descending
select new { m, m.NbVariables }

// Methods where NbVariables &gt; 8 are hard to understand and maintain.
// Methods where NbVariables &gt; 15 are extremely complex 
// and should be split in smaller methods.
// See the definition of the Nbvariables metric here 
// http://www.jarchitect.com/Metrics.aspx#Nbvariables</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Methods with too many overloads&lt;/Name&gt;
warnif count &gt; 0 from m in JustMyCode.Methods where 
  m.NbOverloads &gt; 6 
  orderby m.NbOverloads descending
select new { m, m.NbOverloads }

// Methods where NbOverloads &gt; 6 might 
// be a problem to maintain and provoke higher coupling 
// than necessary. 
// See the definition of the NbOverloads metric here 
// http://www.jarchitect.com/Metrics.aspx#NbOverloads</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Types with too many methods&lt;/Name&gt;
warnif count &gt; 0 from t in JustMyCode.Types where 
  t.Methods.Count() &gt; 20 
  orderby t.Methods.Count() descending
select new { t, t.InstanceMethods, t.StaticMethods }

// Types where Methods.Count() &gt; 20 might be hard to 
// understand and maintain 
// but there might be cases where it is relevant 
// to have a high number of methods. 
</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Types with too many fields&lt;/Name&gt;
warnif count &gt; 0 from t in JustMyCode.Types where 
  t.Fields.Count() &gt; 20 &amp;&amp; 
  !t.IsEnumeration 
  orderby t.Fields.Count() descending
select new { t, t.InstanceFields, t.StaticFields, t.SizeOfInst }

// Types where Fields.Count() &gt; 20 and not IsEnumeration 
// might be hard to understand and maintain 
// but there might be cases where it is relevant 
// to have a high number of fields. 
</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Types with poor cohesion&lt;/Name&gt;
warnif count &gt; 0 from t in JustMyCode.Types where 
  (t.LCOM &gt; 0.8 || t.LCOMHS &gt; 0.95) &amp;&amp; 
  t.NbFields &gt; 10 &amp;&amp; 
  t.NbMethods &gt;10 
  orderby t.LCOM descending, t.LCOMHS descending
select new { t, t.LCOM, t.LCOMHS, 
                t.NbMethods, t.NbFields }

// Types where LCOM &gt; 0.8 and NbFields &gt; 10 
// and NbMethods &gt;10 might be problematic. 
// However, it is very hard to avoid such 
// non-cohesive types. The LCOMHS metric
// is often considered as more efficient to 
// detect non-cohesive types.
// See the definition of the LCOM metric here 
// http://www.jarchitect.com/Metrics.aspx#LCOM</Query>
    </Group>
    <Group Active="True" Name="Code Quality Regression" ShownInReport="False">
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;From now, all methods added or refactored should respect basic quality principles&lt;/Name&gt;
warnif count &gt; 0 from m in JustMyCode.Methods where

// *** Only new or modified methods since Baseline for Comparison ***
 (m.WasAdded() || m.CodeWasChanged()) &amp;&amp;
 
// Low Quality methods// Metrics' definitions
(  m.NbLinesOfCode &gt; 30 ||          // http://www.jarchitect.com/Metrics.aspx#NbLinesOfCode
   m.NbBCInstructions &gt; 200 ||      // http://www.jarchitect.com/Metrics.aspx#NbBCInstructions
   m.CyclomaticComplexity &gt; 20 ||   // http://www.jarchitect.com/Metrics.aspx#CC
   m.BCCyclomaticComplexity &gt; 50 || // http://www.jarchitect.com/Metrics.aspx#ILCC
   m.BCNestingDepth &gt; 4 ||          // http://www.jarchitect.com/Metrics.aspx#BCNestingDepth
   m.NbParameters &gt; 5 ||            // http://www.jarchitect.com/Metrics.aspx#NbParameters
   m.NbVariables &gt; 8 ||             // http://www.jarchitect.com/Metrics.aspx#NbVariables
   m.NbOverloads &gt; 6 )
select new { m, m.NbLinesOfCode, m.NbBCInstructions, m.CyclomaticComplexity, 
             m.BCCyclomaticComplexity, m.BCNestingDepth, 
             m.NbParameters, m.NbVariables, m.NbOverloads }  // http://www.jarchitect.com/Metrics.aspx#NbOverloads


// This rule warns if a method with
// low-quality has been added or refactored.
// With JArchitect and such rule, you can
// Ensure Quality From Now! as explained here:
// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/01/ensure-the-quality-of-the-code-that-will-be-developed-this-year.aspx
</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;From now, all types added or refactored should respect basic quality principles&lt;/Name&gt;
warnif count &gt; 0 from t in JustMyCode.Types where

// *** Only match new or modified types since Baseline for Comparison ***
(t.WasAdded() || t.CodeWasChanged()) &amp;&amp;

// Eliminate interfaces, enumerations or types only with constant fields
// by making sure we are matching type with code.
t.NbLinesOfCode &gt; 10 &amp;&amp;

// Low Quality types     Metrics' definitions are available here:
//     http://www.jarchitect.com/Metrics.aspx#MetricsOnTypes
(  // Types with too many methods
   t.NbMethods &gt; 20 ||

   // Types with too many fields
   t.NbFields &gt; 20 ||

   // Complex Types that use more than 50 other types
   t.NbTypesUsed &gt; 50
)
select new { t, t.Methods, t.Fields, t.TypesUsed }


// This rule warns if a type with
// low-quality has been added or refactored.
// With JArchitect and such rule, you can
// Ensure Quality From Now! as explained here:
// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/01/ensure-the-quality-of-the-code-that-will-be-developed-this-year.aspx
</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;From now, all types added or refactored should be 100% covered by tests&lt;/Name&gt;
warnif count &gt; 0 from t in JustMyCode.Types where

  // Match methods new or modified since Baseline for Comparison...
  (t.WasAdded() || t.CodeWasChanged()) &amp;&amp;

  // ...that are not 100% covered by tests
  t.PercentageCoverage &lt; 100

  let methodsCulprit = t.Methods.Where(m =&gt; m.PercentageCoverage &lt; 100)

select new { t, t.PercentageCoverage, methodsCulprit }

// Having types 100% covered by tests is a good idea because 
// the small portion of code hard to cover, is also the 
// portion of code that is the most likely to contain bugs.</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid decreasing code coverage by tests of types&lt;/Name&gt;
// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector

warnif count &gt; 0 
from t in JustMyCode.Types where
  t.IsPresentInBothBuilds() &amp;&amp;
  t.PercentageCoverage &lt; t.OlderVersion().PercentageCoverage

select new { t,
    OldCov = t.OlderVersion().PercentageCoverage,
    NewCov = t.PercentageCoverage,
    OldLoc = t.OlderVersion().NbLinesOfCode,
    NewLoc = t.NbLinesOfCode,
}
</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Types that used to be 100% covered but not anymore&lt;/Name&gt;
warnif count &gt; 0
from t in JustMyCode.Types where 
   t.IsPresentInBothBuilds() &amp;&amp;
   t.OlderVersion().PercentageCoverage == 100 &amp;&amp;
   t.PercentageCoverage &lt; 100
let culpritMethods = t.Methods.Where(m =&gt; m.PercentageCoverage &lt; 100)
select new {t, t.PercentageCoverage, culpritMethods }</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid making complex methods even more complex (Source CC)&lt;/Name&gt;
// To visualize changes in code, right-click a matched method and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector

warnif count &gt; 0 
from m in JustMyCode.Methods where
 !m.IsAbstract &amp;&amp;
  m.IsPresentInBothBuilds() &amp;&amp;
  m.CodeWasChanged()

let oldCC = m.OlderVersion().CyclomaticComplexity
where oldCC &gt; 6 &amp;&amp; m.CyclomaticComplexity &gt; oldCC 

select new { m,
    oldCC ,
    newCC = m.CyclomaticComplexity ,
    oldLoc = m.OlderVersion().NbLinesOfCode,
    newLoc = m.NbLinesOfCode,
}
</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid making complex methods even more complex (BC CC)&lt;/Name&gt;
// To visualize changes in code, right-click a matched method and select:
//  - Compare older and newer versions of source file


warnif count &gt; 0 
from m in JustMyCode.Methods where
 !m.IsAbstract &amp;&amp;
  m.IsPresentInBothBuilds() &amp;&amp;
  m.CodeWasChanged()

let oldCC = m.OlderVersion().BCCyclomaticComplexity
where oldCC &gt; 10 &amp;&amp; m.BCCyclomaticComplexity &gt; oldCC 

select new { m,
    oldCC ,
    newCC = m.BCCyclomaticComplexity ,
    oldLoc = m.OlderVersion().NbLinesOfCode,
    newLoc = m.NbLinesOfCode,
}

</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid making large methods even larger&lt;/Name&gt;
// To visualize changes in code, right-click a matched method and select:
//  - Compare older and newer versions of source file


warnif count &gt; 0 
from m in JustMyCode.Methods where
 !m.IsAbstract &amp;&amp;
  m.IsPresentInBothBuilds() &amp;&amp;
  m.CodeWasChanged() &amp;&amp;
 // Eliminate constructors from match, since they get larger
 // as soons as some fields initialization are added.
 !m.IsConstructor &amp;&amp;
 !m.IsClassConstructor

let oldLoc = m.OlderVersion().NbLinesOfCode
where oldLoc &gt; 15 &amp;&amp; m.NbLinesOfCode &gt; oldLoc

select new { m,
    oldLoc,
    newLoc = m.NbLinesOfCode,
}

</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid adding methods to a type that already had many methods&lt;/Name&gt;
// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file


warnif count &gt; 0 
from t in JustMyCode.Types where
  t.IsPresentInBothBuilds() &amp;&amp;
  t.Methods.Count() &gt; t.OlderVersion().Methods.Count() &amp;&amp;
  t.OlderVersion().Methods.Count() &gt; 10

let newMethods = t.Methods.Where(m =&gt; m.WasAdded())
let removedMethods = t.OlderVersion().Methods.Where(m =&gt; m.WasRemoved())

select new { t,
             oldNbMethods = t.OlderVersion().NbMethods,
             newNbMethods = t.NbMethods,
             newMethods,
             removedMethods  }</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">//&lt;Name&gt;Avoid transforming an immutable type into a mutable one&lt;/Name&gt;
// Users of an immutable type often rely on the fact that the type is immutable.
// If an immutable type becomes mutable, there are chances that this will break its users.
warnif count &gt; 0
from t in Application.Types where
   t.IsPresentInBothBuilds() &amp;&amp;
   t.OlderVersion().IsImmutable &amp;&amp;
  !t.IsImmutable &amp;&amp; 
  // Don't take account of immutable types transformed into static types (not deemed as immtable)
  !t.IsStatic
let culpritFields = t.Fields.Where(f =&gt; f.IsImmutable)
select new {t, culpritFields }</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid transforming an immutable field into a mutable one&lt;/Name&gt;
// Users of an immutable field often rely on the fact that the type is immutable.
// If an immutable field becomes mutable, there are chances that this will break its users.
warnif count &gt; 0
from f in Application.Fields where 
   f.IsPresentInBothBuilds() &amp;&amp;
   f.OlderVersion().IsImmutable &amp;&amp;
  !f.IsImmutable 
select f</Query>
      <Query Active="False" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid adding instance fields to a type that already had many instance fields&lt;/Name&gt;
// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file


warnif count &gt; 0 
from t in JustMyCode.Types where
  t.IsPresentInBothBuilds() &amp;&amp;
 !t.IsStatic

let oldNbInstanceFields = t.OlderVersion().InstanceFields
let newNbInstanceFields = t.InstanceFields
where
  newNbInstanceFields.Count() &gt; oldNbInstanceFields .Count() &amp;&amp;
  oldNbInstanceFields.Count() &gt; 6

let newInstanceFields = t.InstanceFields.Where(f =&gt; f.WasAdded())

select new { t,
             oldCount = oldNbInstanceFields.Count() ,
             newCount = newNbInstanceFields.Count() ,
             newInstanceFields }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False"> // &lt;Name&gt; Clone Detectors Query&lt;/Name&gt;
warnif count &gt; 0 from m in JustMyCode.Methods where (m.IsMethod)

select new { m, m.FullName, m.Name, m.CyclomaticComplexity, m.MethodsCalled, 
             m.NbMethodsCalled, m.MethodsCallingMe, m.NbMethodsCallingMe, 
             m.NbParameters, m.NbVariables, m.Rank, 
             m.IsOverloaded, m.ParentType, 
             m.ParentProject, m.ParentPackage}</Query>
    </Group>
    <Group Active="False" Name="Object Oriented Design" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Base class should not use derivatives&lt;/Name&gt;
warnif count &gt; 0 
from baseClass in JustMyCode.Types
where baseClass.IsClass &amp;&amp; baseClass.NbChildren &gt; 0 // &lt;-- for optimization!
let derivedClassesUsed = baseClass.DerivedTypes.UsedBy(baseClass)
where derivedClassesUsed.Count() &gt; 0
select new { baseClass, derivedClassesUsed }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Class shouldn't be too deep in inheritance tree&lt;/Name&gt;
warnif count &gt; 0 from t in JustMyCode.Types 
where t.IsClass
let baseClasses = t.BaseClasses.ExceptThirdParty()

// Warn for classes with 3 or more base classes.
// Notice that we don't count third-party classes 
// because this rule concerns your code design,
// not third-party libraries consumed design.
where baseClasses.Count() &gt;= 3

select new { t, baseClasses, 
                // The metric value DepthOfInheritance takes account
                // of third-party base classes
                t.DepthOfInheritance } 

// Branches too long in the derivation should be avoided.
// See the definition of the DepthOfInheritance metric here 
// http://www.jarchitect.com/Metrics.aspx#DIT
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Class with no descendant should be final if possible&lt;/Name&gt;
warnif count &gt; 0 from t in JustMyCode.Types where 
  t.IsClass &amp;&amp; 
  t.NbChildren ==0 &amp;&amp; 
 !t.IsFinal &amp;&amp; 
 !t.IsStatic 
  // &amp;&amp; !t.IsPublic &lt;-- You might want to add this condition 
  //                    if you are developping a framework
  //                    with classes that are intended to be 
  //                    sub-classed by your clients.
  orderby t.NbLinesOfCode descending
select new { t, t.NbLinesOfCode }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">//&lt;Name&gt;Avoid the Singleton pattern&lt;/Name&gt;
warnif count &gt; 0
from t in Application.Types
where !t.IsStatic &amp;&amp; !t.IsAbstract &amp;&amp; t.IsClass 

// All ctors of a singleton are private
where t.Constructors.Where(ctor =&gt; !ctor.IsPrivate).Count() == 0

// A singleton contains one static field of its parent type, to reference the unique instance
let staticFieldInstances = t.StaticFields.WithFieldType(t)
where staticFieldInstances.Count() == 1
select new { t, staticFieldInstance = staticFieldInstances.First() }

// The Singleton pattern consists in syntactically enforcing that a class 
// has just one unique instance.
// At first glance, this pattern looks appealing and it is widely used.
// However, we discourage you from using singleton classes because experience
// shows that singletons often result in less testable and less maintainable code.
// More details available in these discussions:
//  http://adamschepis.com/blog/2011/05/02/im-adam-and-im-a-recovering-singleton-addict/
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Don't assign static fields from instance methods&lt;/Name&gt;
// Assigning static fields from instance methods leads to
// poorly maintainable and non thread-safe code.
// It is advised to assign static fields inline or from class constructor.
warnif count &gt; 0
from f in Application.Fields where 
  f.IsStatic &amp;&amp;
 !f.IsLiteral &amp;&amp;
 !f.IsInitOnly &amp;&amp;
 !f.IsGeneratedByCompiler &amp;&amp;
  // Contract API define such a insideContractEvaluation static field
  f.Name != "insideContractEvaluation"
let assignedBy = f.MethodsAssigningMe.Where(m =&gt; !m.IsStatic)
where assignedBy .Count() &gt; 0
select new { f, assignedBy }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid empty interfaces&lt;/Name&gt;
warnif count &gt; 0 from t in JustMyCode.Types where 
  t.IsInterface &amp;&amp; 
  t.NbMethods == 0
select new { t, t.TypesThatImplementMe }

// Interfaces define members that provide a behavior 
// or usage contract. The functionality described by 
// the interface can be adopted by any type, 
// regardless of where the type appears in the 
// inheritance hierarchy. A type implements an 
// interface by providing implementations for the 
// interface's members. An empty interface does not 
// define any members, and as such, does not define 
// a contract that can be implemented.

// If your design includes empty interfaces that 
// types are expected to implement, you are probably 
// using an interface as a marker, or a way of 
// identifying a group of types. If this identification 
// will occur at runtime, the correct way to accomplish
// this is to use a custom attribute. Use the presence 
// or absence of the attribute, or the attribute's 
// properties, to identify the target types. If the 
// identification must occurs at compile time, then using 
// an empty interface is acceptable.</Query>
    </Group>
    <Group Active="False" Name="Design" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid packages with few types&lt;/Name&gt;
warnif count &gt; 0 from n in JustMyCode.Packages 
let types = n.ChildTypes.Where(t =&gt; !t.IsGeneratedByCompiler)
where 
  types.Count() &lt; 5 
  orderby types.Count() ascending
select new { n, types } 

// Make sure that there is a logical organization 
// to each of your packages, and that there is a 
// valid reason for putting types in a sparsely 
// populated package. Packages should contain 
// types that are used together in most scenarios. 
// When their applications are mutually exclusive, 
// types should be located in separate packages</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Nested types should not be visible&lt;/Name&gt;
warnif count &gt; 0 from t in JustMyCode.Types where 
  t.IsNested &amp;&amp; 
 !t.IsGeneratedByCompiler &amp;&amp;
 !t.IsPrivate 
select new { t, t.NbLinesOfCode, t.Visibility } 


// A nested type is a type declared within the 
// scope of another type. Nested types are useful 
// for encapsulating private implementation details 
// of the containing type. Used for this purpose, 
// nested types should not be externally visible. 
// Do not use externally visible nested types for 
// logical grouping or to avoid name collisions; 
// instead, use packages.</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Instances size shouldn't be too big&lt;/Name&gt;
warnif count &gt; 0 from t in JustMyCode.Types where 
  t.SizeOfInst &gt; 64 
  orderby t.SizeOfInst descending
select new { t, t.SizeOfInst, t.InstanceFields }

// Types where SizeOfInst &gt; 64 might degrade performance 
// (depending on the number of instances created at runtime) 
// and might be hard to maintain. However it is not a rule 
// since sometime there is no alternative .
// Notice that a class with a large SizeOfInst value
// doesn't necessarily have a lot of instance fields.
// It might derive from a class with a large SizeOfInst value.
// See the definition of the SizeOfInst metric here 
// http://www.jarchitect.com/Metrics.aspx#SizeOfInst</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Don't use obsolete types, methods or fields&lt;/Name&gt;   
warnif count &gt; 0
let obsoleteTypes = Types.Where(t =&gt; t.IsObsolete)
let obsoleteMethods = Methods.Where(m =&gt; m.IsObsolete).ToHashSet()
let obsoleteFields = Fields.Where(f =&gt; f.IsObsolete)

from m in JustMyCode.Methods.UsingAny(obsoleteTypes).Union(
          JustMyCode.Methods.UsingAny(obsoleteMethods)).Union(
          JustMyCode.Methods.UsingAny(obsoleteFields))
let obsoleteTypesUsed = obsoleteTypes.UsedBy(m)

// Optimization: MethodsCalled + Intersect() is faster than using obsoleteMethods.UsedBy()
let obsoleteMethodsUsed = m.MethodsCalled.Intersect(obsoleteMethods)
let obsoleteFieldsUsed = obsoleteFields.UsedBy(m)
select new { m, obsoleteTypesUsed, obsoleteMethodsUsed, obsoleteFieldsUsed }</Query>
    </Group>
    <Group Active="False" Name="Architecture and Layering" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid packages mutually dependent&lt;/Name&gt;
warnif count &gt; 0
// Foreach pair of package mutually dependent, this rule lists pairs.
// The pair { first, second } is formatted to show that first package shouldn't use the second package.
// The first/second order is inferred from the number of types used by each other.
// The first package is using less types of the second.
// It means that the first package is certainly at a lower level in the architecture, than the second.
//
// To explore the coupling between two packages mutually dependent:
//  1) export the first package to the vertical header of the dependency matrix
//  2) export the second package to the horizontal header of the dependency matrix
//  3) double-click the black cell
//  4) in the matrix command bar, click the button: Remove empty Row(s) en Column(s)
// At this point, the dependency matrix shows types involved into the coupling.
//
// Following this rule is useful to avoid packages dependency cycles.

// Optimization: restreint application projects set
// If some packages are mutually dependent
//  - They must be declared in the same project
//  - The parent project must ContainsPackageDependencyCycle
from project in Application.Projects.Where(a =&gt; a.ContainsPackageDependencyCycle != null &amp;&amp; a.ContainsPackageDependencyCycle.Value)

// hashset is used to avoid reporting both A &lt;-&gt; B and B &lt;-&gt; A
let hashset = new HashSet&lt;IPackage&gt;()

// Optimization: restreint packages set
// If a package doesn't have a Level value, it must be in a dependency cycle
// or it must be using directly or indirectly a dependency cycle.
let packagesSuspect = project.ChildPackages.Where(n =&gt; n.Level == null)

from nA in packagesSuspect

// Select PACKAGES mutually dependent with nA
let unused = hashset.Add(nA) // Populate hashset
let packagesMutuallyDependentWith_nA = nA.PackagesUsed.Using(nA)
          .Except(hashset) // &lt;-- avoid reporting both A &lt;-&gt; B and B &lt;-&gt; A 
where packagesMutuallyDependentWith_nA.Count() &gt; 0

from nB in packagesMutuallyDependentWith_nA

// nA and nB are mutually dependent
// Select first the one that shouldn't use the other.
// The first package is inferred from the fact that it is using less types of the second.
let typesOfBUsedByA = nB.ChildTypes.UsedBy(nA)
let typesOfAUsedByB = nA.ChildTypes.UsedBy(nB)
let first = (typesOfBUsedByA.Count() &gt; typesOfAUsedByB.Count()) ? nB : nA
let second = (first == nA) ? nB : nA
let typesOfFirstUsedBySecond = (first == nA) ? typesOfAUsedByB : typesOfBUsedByA
let typesOfSecondUsedByFirst = (first == nA) ? typesOfBUsedByA : typesOfAUsedByB
select new { first, shouldntUse = second, typesOfFirstUsedBySecond, typesOfSecondUsedByFirst }
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid packages dependency cycles&lt;/Name&gt;
warnif count &gt; 0
// This query lists all application packages dependency cyles.
// Each row shows a different cycle, prefixed with a package entangled in the cycle.
//
// To browse a cycle on the dependency graph or the dependency matrix, just right click
// a cycle cell and export packages matched to the dependency graph or matrix!
//
// In the matrix, dependency cycles are represented with red squares and black cells.
// To browse easily dependency cycles, the Matrix comes with the option:
//   --&gt; Display Direct and Indirect Dependencies
//



// Optimization: restreint application projects set
// If some packages are mutually dependent
//  - They must be declared in the same project
//  - The parent project must ContainsPackageDependencyCycle
from project in Application.Projects
                 .Where(a =&gt; a.ContainsPackageDependencyCycle != null &amp;&amp; 
                             a.ContainsPackageDependencyCycle.Value)

// Optimization: restreint packages set
// A package involved in a cycle necessarily have a null Level.
let packagesSuspect = project.ChildPackages.Where(n =&gt; n.Level == null)

// hashset is used to avoid iterating again on packages already caught in a cycle.
let hashset = new HashSet&lt;IPackage&gt;()


from suspect in packagesSuspect
   // By commenting this line, the query matches all packages involved in a cycle.
   where !hashset.Contains(suspect)

   // Define 2 code metrics
   // - Packages depth of is using indirectly the suspect package.
   // - Packages depth of is used by the suspect package indirectly.
   // Note: for direct usage the depth is equal to 1.
   let packagesUserDepth = packagesSuspect.DepthOfIsUsing(suspect)
   let packagesUsedDepth = packagesSuspect.DepthOfIsUsedBy(suspect)

   // Select PACKAGES that are both using and used by packageSuspect
   let usersAndUsed = from n in packagesSuspect where 
                         packagesUserDepth[n] &gt; 0 &amp;&amp; 
                         packagesUsedDepth[n] &gt; 0 
                      select n

   where usersAndUsed.Count() &gt; 0

   // Here we've found package(s) both using and used by the suspect package.
   // A cycle involving the suspect package is found!
   let cycle = usersAndUsed.Append(suspect)

   // Fill hashset with packages in the cycle.
   // .ToArray() is needed to force the iterating process.
   let unused1 = (from n in cycle let unused2 = hashset.Add(n) select n).ToArray()

select new { suspect, cycle }
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Projects with poor cohesion (RelationalCohesion)&lt;/Name&gt;
warnif count &gt; 0 from a in Application.Projects where 
  a.NbTypes &gt; 20 &amp;&amp; // Relational Cohesion metrics is relevant only if there are several types 
  (a.RelationalCohesion &lt; 1.5 || 
   a.RelationalCohesion &gt; 4.0)
select new { a, a.NbTypes, a.RelationalCohesion }

// As classes inside an project should be strongly related, 
// the cohesion should be high. On the other hand, a value 
// which is too high may indicate over-coupling. A good range 
// for RelationalCohesion is 1.5 to 4.0.
// See the definition of the RelationalCohesion metric here 
// http://www.jarchitect.com/Metrics.aspx#RelationalCohesion</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Projects that don't satisfy the Abstractness/Instability principle&lt;/Name&gt;
warnif percentage &gt; 15 from a in Application.Projects where 
  a.NormDistFromMainSeq &gt; 0.7 
  orderby a.NormDistFromMainSeq descending
select new { a, a.NormDistFromMainSeq }

// See the definition of the NormDistFromMainSeq metric here 
// http://www.jarchitect.com/Metrics.aspx#DitFromMainSeq</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Example of custom rule to check for dependency&lt;/Name&gt;

// To define a rule that warns if a particular dependency exist or not, 
// from a code element A to a code element B
// A and B being an project package Type Method or Field,
// A and B not necessarily two Projects or two Packages...
// you can first, right click the cell in the Dependency Matrix
// with B in row and A in column,
// or right-click the concerned arrow in the Dependency Graph
// from A to B, and choose to: 
// "Generate a code rule that warns if this dependency exists"
//
// The generated rule will look like the one below.
// It is now up to you to adapt this rule to check your needs.

warnif count &gt; 0 from a in Projects
where 
a.IsUsing("Foo1.Foo2".AllowNoMatch().MatchPackage()) &amp;&amp;
(a.Name == @"Foo3") 
select new { a, a.NbLinesOfCode }
// the project Foo3
// shouldn't use directly 
// the package Foo3.Foo4
// because (TODO insert your reason)
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Higher cohesion - lower coupling&lt;/Name&gt;
// It is deemed as a good software architecture practice to clearly separate
// 'abstract' packages containing only abstractions (interfaces, enumerations, delegates)
// from other 'concrete' packages, that contains classes
//
// Typically, the more concrete packages rely on abstract packages *only*,
// the more Decoupled is the architecture, and the more Cohesive are 
// classes inside concrete packages.
//
// The following code query, define sets of abstract and concrete packages
// and shows for each concrete packages, which concrete and abstract packages are used.
// 
// This query can be adapted to a rule, depending on how much you want
// your code architecture being decoupled.
//

let abstractpackages = JustMyCode.Packages.Where(
     n =&gt; n.ChildTypes.Where(t =&gt; !t.IsInterface &amp;&amp; !t.IsEnumeration).Count() == 0
).ToHashSet()

let concretepackages = JustMyCode.Packages.Except(abstractpackages).ToHashSet()

from n in concretepackages
let packagesUsed = n.PackagesUsed.ExceptThirdParty()
let concretepackagesUsed = packagesUsed.Except(abstractpackages)
let abstractpackagesUsed = packagesUsed.Except(concretepackages)
select new { n, concretepackagesUsed , abstractpackagesUsed }</Query>
    </Group>
    <Group Active="False" Name="Plugins" ShownInReport="False">
      <Group Active="True" Name="PMD Queries" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;All Pmd Violations&lt;/Name&gt;
from issue in Issues  where issue.ToolName=="Pmd"
select new { issue,issue.FilePath,issue.BeginLine }</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Most prioritary Pmd violations&lt;/Name&gt;
(from issue in Issues where issue.ToolName=="Pmd"
orderby  issue.Priority ascending
select new { issue,issue.Priority,issue.FilePath,issue.BeginLine }).Take(100)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Most Classes violating Pmd rules&lt;/Name&gt;
(from t in Types where t.Issues.Where(i=&gt;i.ToolName=="Pmd").Count()&gt;0
orderby t.Issues.Count() descending
select new { t,nbIssues=t.Issues.Count() }).Take(100)

</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Most Methods violating Pmd rules&lt;/Name&gt;
(from m in Methods where m.Issues.Where(i=&gt;i.ToolName=="Pmd").Count()&gt;0
orderby m.Issues.Count() descending
select new { m,nbIssues=m.Issues.Count() }).Take(100)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Most Project violating Pmd rules&lt;/Name&gt;
(from p in Projects where p.Issues.Where(i=&gt;i.ToolName=="Pmd").Count()&gt;0
orderby p.Issues.Count() descending
select new { p,nbIssues=p.Issues.Count() }).Take(5)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Most Recurrent Pmd violations&lt;/Name&gt;
let groups = Application.Issues.Where(i=&gt;i.ToolName=="Pmd").GroupBy(t =&gt; t.Type)

from g in groups
orderby g.Count() descending
select new { issue=g.FirstOrDefault(),count=g.Count() }</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Popular Methods violating Pmd rules&lt;/Name&gt;
(from m in Methods where m.Issues.Where(i=&gt;i.ToolName=="Pmd").Count()&gt;0
orderby m.MethodsCallingMe.Count() descending
select new { m,NbCallingMethods= m.MethodsCallingMe }).Take(100)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Popular Classes violating Pmd rules&lt;/Name&gt;
from t in Types where t.Issues.Where(i=&gt;i.ToolName=="Pmd").Count()&gt;0
orderby t.TypesUsingMe.Count() descending
select new { t,ClassesUsingMe= t.TypesUsingMe}</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Pmd Violation Famillies with Most violations &lt;/Name&gt;
let groups = Application.Issues.Where(i=&gt;i.ToolName=="Pmd").GroupBy(t =&gt; t.IssueFamilly)

from g in groups
orderby g.Count() descending
select new { issue=g.FirstOrDefault(),count=g.Count() }</Query>
      </Group>
      <Group Active="True" Name="FindBugs Queries" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;All FindBugs Violations&lt;/Name&gt;
from issue in Issues  where issue.ToolName=="FindBugs"
select new { issue,issue.FilePath,issue.BeginLine }</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Most prioritary FindBugs violations&lt;/Name&gt;
(from issue in Issues where issue.ToolName=="FindBugs"
orderby  issue.Priority ascending
select new { issue,issue.Priority,issue.FilePath,issue.BeginLine }).Take(100)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Most Classes violating FindBugs rules&lt;/Name&gt;
(from t in Types where t.Issues.Where(i=&gt;i.ToolName=="FindBugs").Count()&gt;0
orderby t.Issues.Count() descending
select new { t,nbIssues=t.Issues.Count() }).Take(100)

</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Most Methods violating FindBugs rules&lt;/Name&gt;
(from m in Methods where m.Issues.Where(i=&gt;i.ToolName=="FindBugs").Count()&gt;0
orderby m.Issues.Count() descending
select new { m,nbIssues=m.Issues.Count() }).Take(100)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Most Project violating FindBugs rules&lt;/Name&gt;
(from p in Projects where p.Issues.Where(i=&gt;i.ToolName=="FindBugs").Count()&gt;0
orderby p.Issues.Count() descending
select new { p,nbIssues=p.Issues.Count() }).Take(5)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Most Recurrent FindBugs violations&lt;/Name&gt;
let groups = Application.Issues.Where(i=&gt;i.ToolName=="FindBugs").GroupBy(t =&gt; t.Type)

from g in groups
orderby g.Count() descending
select new { issue=g.FirstOrDefault(),count=g.Count() }</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Popular Methods violating FindBugs rules&lt;/Name&gt;
(from m in Methods where m.Issues.Where(i=&gt;i.ToolName=="FindBugs").Count()&gt;0
orderby m.MethodsCallingMe.Count() descending
select new { m,NbCallingMethods= m.MethodsCallingMe }).Take(100)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Popular Classes violating FindBugs rules&lt;/Name&gt;
from t in Types where t.Issues.Where(i=&gt;i.ToolName=="FindBugs").Count()&gt;0
orderby t.TypesUsingMe.Count() descending
select new { t,ClassesUsingMe= t.TypesUsingMe}</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;FindBugs Violation Famillies with Most violations &lt;/Name&gt;
let groups = Application.Issues.Where(i=&gt;i.ToolName=="FindBugs").GroupBy(t =&gt; t.IssueFamilly)

from g in groups
orderby g.Count() descending
select new { issue=g.FirstOrDefault(),count=g.Count() }</Query>
      </Group>
      <Group Active="True" Name="CheckStyle Queries" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;All CheckStyle Violations&lt;/Name&gt;
from issue in Issues  where issue.ToolName=="CheckStyle"
select new { issue,issue.FilePath,issue.BeginLine }</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Most prioritary CheckStyle violations&lt;/Name&gt;
(from issue in Issues where issue.ToolName=="CheckStyle"
where issue.Severity=="error"
select new { issue,issue.Severity,issue.FilePath,issue.BeginLine }).Take(100)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Most Classes violating CheckStyle rules&lt;/Name&gt;
(from t in Types where t.Issues.Where(i=&gt;i.ToolName=="CheckStyle").Count()&gt;0
orderby t.Issues.Count() descending
select new { t,nbIssues=t.Issues.Count() }).Take(100)

</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Most Project violating CheckStyle rules&lt;/Name&gt;
(from p in Projects where p.Issues.Where(i=&gt;i.ToolName=="CheckStyle").Count()&gt;0
orderby p.Issues.Count() descending
select new { p,nbIssues=p.Issues.Count() }).Take(5)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Most Recurrent CheckStyle violations&lt;/Name&gt;
let groups = Application.Issues.Where(i=&gt;i.ToolName=="CheckStyle").GroupBy(t =&gt; t.Type)

from g in groups
orderby g.Count() descending
select new { issue=g.FirstOrDefault(),count=g.Count() }</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Popular Classes violating CheckStyle rules&lt;/Name&gt;
from t in Types where t.Issues.Where(i=&gt;i.ToolName=="CheckStyle").Count()&gt;0
orderby t.TypesUsingMe.Count() descending
select new { t,ClassesUsingMe= t.TypesUsingMe}</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;CheckStyle Violation Famillies with Most violations &lt;/Name&gt;
let groups = Application.Issues.Where(i=&gt;i.ToolName=="CheckStyle").GroupBy(t =&gt; t.IssueFamilly)

from g in groups
orderby g.Count() descending
select new { issue=g.FirstOrDefault(),count=g.Count() }</Query>
      </Group>
      <Group Active="True" Name="CPD Queries" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;All CPD duplications&lt;/Name&gt;
from issue in Issues  where issue.ToolName=="CPD"
select new { issue,issue.FilePath,issue.BeginLine }</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Most duplicated code lines&lt;/Name&gt;
from issue in Issues  where issue.ToolName=="CPD"
orderby issue.NbDuplicationCopies descending
select new { issue,issue.NbDuplicationCopies }</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Big duplications&lt;/Name&gt;
from issue in Issues  where issue.ToolName=="CPD"
orderby issue.NbLinesCopied descending
select new { issue,issue.NbLinesCopied }</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Classes containing big duplication&lt;/Name&gt;
(from t in Types where t.Issues.Where(i=&gt;i.ToolName=="CPD" &amp;&amp; i.NbLinesCopied&gt;100).Count()&gt;0
orderby t.Issues.Count() descending
select new { t }).Take(100)
</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Classes containing Many duplications&lt;/Name&gt;
(from t in Types where t.Issues.Where(i=&gt;i.ToolName=="CPD" &amp;&amp; i.NbDuplicationCopies&gt;10).Count()&gt;0
orderby t.Issues.Count() descending
select new { t }).Take(100)</Query>
      </Group>
    </Group>
    <Group Active="False" Name="Best Practices" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid creating unnecessary strings&lt;/Name&gt;
warnif count &gt; 0 from m in Methods 
let depth0 = m.DepthOfCreateA("java.lang.String".AllowNoMatch())
where depth0  == 1
select new { m, depth0 }

//String s = new String("stringette"); // DON'T DO THIS!
//The statement creates a new String instance each time it is executed, and
//none of those object creations is necessary. The argument to the String constructor ("stringette") is itself a String instance,
//functionally identical to all of the objects created by the constructor. If this usage occurs in a loop or in a frequently
//invoked method, millions of String instances can be created needlessly.
//The improved version is simply the following:
// String s = "stringette";

</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid finalizers&lt;/Name&gt;
warnif count &gt; 0 from m in Methods where m.Name =="finalize()"
select  m

//Don&#8217;t use finalizers except as a safety net or to terminate noncritical native resources. 
//In those rare instances where you do use a finalizer,remember to invoke super.finalize. 

</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Prefer primitive types to boxed primitives&lt;/Name&gt;
warnif count &gt; 0 

let BoxedTypes = ThirdParty.Types.WithFullNameIn(
   "java.lang.Integer",
   "java.lang.Double",
   "java.lang.Boolean")

from m in Application.Methods.UsingAny(BoxedTypes)
select m

//Use primitives in preference to boxed primitives whenever you
//have the choice. Primitive types are simpler and faster. If you must use boxed
//primitives, be careful! Autoboxing reduces the verbosity, but not the danger, of
//using boxed primitives. When your program compares two boxed primitives
//with the == operator, it does an identity comparison, which is almost certainly not
//what you want.

</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Always override hashcode when you override equals&lt;/Name&gt;
warnif count &gt; 0 
from t in Types where !t.IsThirdParty &amp;&amp; t.Methods.Where(a=&gt;a.Name=="equals(Object)").Count()&gt;0
&amp;&amp; t.Methods.Where(a=&gt;a.Name=="hashCode()").Count()==0
select t


</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Always override toString&lt;/Name&gt;
warnif count &gt; 0 
from t in Types where !t.IsThirdParty &amp;&amp;  t.IsClass &amp;&amp; t.Methods.Where(a=&gt;a.Name=="toString()").Count()==0
select t

//While java.lang.Object provides an implementation of the toString method,
//the string that it returns is generally not what the user of your class wants to see. I

</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Prefer interfaces to abstract classes&lt;/Name&gt;
warnif count &gt; 0 
from t in Types where !t.IsThirdParty &amp;&amp;  t.IsAbstract
select t


</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Use interfaces only to define types&lt;/Name&gt;
warnif count &gt; 0 
from t in Types where !t.IsThirdParty &amp;&amp;  t.IsInterface &amp;&amp; t.NbMethods==0
select t


</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid using raw types&lt;/Name&gt;
warnif count &gt; 0 

let rawTypes = ThirdParty.Types.WithFullNameIn(
  "java.util.Collection")

from m in Application.Methods.UsingAny(rawTypes)
select m



</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Don't force gabrage collector&lt;/Name&gt;
warnif count &gt; 0 from m in Methods where m.IsUsing ("java.lang.System.gc()".AllowNoMatch())
select new { m, m.NbBCInstructions }



</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Do not raise generic exception&lt;/Name&gt;
warnif count &gt; 0  from m in Methods 
let depth0 = m.DepthOfCreateA("java.lang.Exception".AllowNoMatch())
where depth0  == 1
select new { m, depth0 }



</Query>
      <Query Active="True" DisplayList="False" DisplaySelectionView="False" DisplayStat="False" IsCriticalRule="False">// &lt;Name&gt;Caution with List.Contains()&lt;/Name&gt;
let containsMethods = ThirdParty.Methods.WithFullNameIn(
   "java.util.List&lt;E&gt;.contains(Object)",
   "java.util.ArrayList&lt;E&gt;.contains(Object)")
from m in Application.Methods.UsingAny(containsMethods) 
select m

// The cost of checking if a list contains an 
// object is proportional to the size of the list 
// (O(N) operation). For large lists and/or frequent 
// calls to Contains(), prefer using the 
// System.Collections.Generic.HashSet&lt;T&gt; class 
// where calls to Contains() takes a constant 
// time (O(0) operation).</Query>
      <Query Active="True" DisplayList="False" DisplaySelectionView="False" DisplayStat="False" IsCriticalRule="False">// &lt;Name&gt;Prefer return collection abstraction instead of implementation&lt;/Name&gt;
let implTypes = ThirdParty.Types.WithFullNameIn(
   "java.util.HashMap&lt;K,V&gt;",
   "java.util.Dictionary&lt;K,V&gt;",
   "java.util.ArrayList&lt;E&gt;",
   "java.util.HashSet&lt;E&gt;")

from m in Application.Methods.WithReturnTypeIn(implTypes) 
select new { m, m.ReturnType }

// Most of the time, clients of a method doesn't 
// need to know the exact implementation of the 
// collection returned. It is preferrable to return 
// a collection interface.</Query>
    </Group>
    <Group Active="False" Name="API Breaking Changes" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="True">// &lt;Name&gt;API Breaking Changes: Types&lt;/Name&gt;
// This rule warns if a publicly visible type is 
// not publicly visible anymore or if it has been removed.
// Such type can break the code of your clients.

warnif count &gt; 0 from t in codeBase.OlderVersion().Application.Types
where t.IsPubliclyVisible &amp;&amp; 

     // The type has been removed and its parent project hasn't been removed ...
     ( (t.WasRemoved() &amp;&amp; !t.ParentProject.WasRemoved()) ||

     // ... or the type is not publicly visible anymore
       !t.WasRemoved() &amp;&amp; !t.NewerVersion().IsPubliclyVisible)

select new { t,
             NewVisibility = (t.WasRemoved() ? " " : t.NewerVersion().Visibility.ToString()) }
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="True">// &lt;Name&gt;API Breaking Changes: Methods&lt;/Name&gt;
// This rule warns if a publicly visible method is 
// not publicly visible anymore or if it has been removed.
// Such method can break the code of your clients.

warnif count &gt; 0 from m in codeBase.OlderVersion().Application.Methods
where m.IsPubliclyVisible &amp;&amp; 

     // The method has been removed and its parent type hasn't been removed ...
     ( (m.WasRemoved() &amp;&amp; !m.ParentType.WasRemoved()) ||

     // ... or the method is not publicly visible anymore
       !m.WasRemoved() &amp;&amp; !m.NewerVersion().IsPubliclyVisible)

select new { m,
             NewVisibility = (m.WasRemoved() ? " " : m.NewerVersion().Visibility.ToString()) }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="True">// &lt;Name&gt;API Breaking Changes: Fields&lt;/Name&gt;
// This rule warns if a publicly visible field is 
// not publicly visible anymore or if it has been removed.
// Such field can break the code of your clients.

warnif count &gt; 0 from f in codeBase.OlderVersion().Application.Fields
where f.IsPubliclyVisible &amp;&amp;

     // The field has been removed and its parent type hasn't been removed ...
     ( (f.WasRemoved() &amp;&amp; !f.ParentType.WasRemoved()) ||

     // ... or the field is not publicly visible anymore
       !f.WasRemoved() &amp;&amp; !f.NewerVersion().IsPubliclyVisible)

select new { f,
             NewVisibility = (f.WasRemoved() ? " " : f.NewerVersion().Visibility.ToString()) }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="True">// &lt;Name&gt;API Breaking Changes: Interfaces and Abstract Classes&lt;/Name&gt;
// This rule warns if a publicly visible interface or abstract class 
// has been changed and contains new abstract methods or 
// if some abstract methods have been removed.
// This can break the code of clients 
// that implement such interface or derive from such abstract class.

warnif count &gt; 0 from tNewer in Application.Types where 
 (tNewer.IsInterface || tNewer.IsClass &amp;&amp; tNewer.IsAbstract) &amp;&amp; 
  tNewer.IsPubliclyVisible &amp;&amp; 
  tNewer.IsPresentInBothBuilds()

let tOlder = tNewer.OlderVersion() where tOlder.IsPubliclyVisible

let methodsRemoved = tOlder.Methods.Where(m =&gt; m.IsAbstract &amp;&amp; m.WasRemoved())
let methodsAdded = tNewer.Methods.Where(m =&gt; m.IsAbstract &amp;&amp; m.WasAdded())

where methodsAdded.Count() &gt; 0 || methodsRemoved.Count() &gt; 0
select new { tNewer, methodsAdded, methodsRemoved }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="True">// &lt;Name&gt;Avoid transforming immutable types into mutable types&lt;/Name&gt;

// Immutability is a strong property on a type.
// Breaking immutability can result in serious problem for an algorithm consummer
// that has been written taking account of the type immutability.

// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file.

warnif count &gt; 0 
from t in Application.Types where
  t.IsPresentInBothBuilds() &amp;&amp;
 !t.IsStatic &amp;&amp;
 !t.IsImmutable &amp;&amp; 
  t.OlderVersion().IsImmutable

let mutableFields = from f in t.InstanceFields where !f.IsImmutable select f

select new { t, mutableFields }

</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;API: New publicly visible types&lt;/Name&gt;
// List types that are new in the public surface of your projects

from t in Application.Types
where t.IsPubliclyVisible &amp;&amp; 

     // The type has been removed and its parent project hasn't been removed ...
     ( (t.WasAdded() &amp;&amp; !t.ParentProject.WasAdded()) ||

     // ... or the type existed but was not publicly visible
       !t.WasAdded() &amp;&amp; !t.OlderVersion().IsPubliclyVisible)

select new { t,
             OldVisibility = (t.WasAdded() ? " " : t.OlderVersion().Visibility.ToString()) }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;API: New publicly visible methods&lt;/Name&gt;
// List methods that are new in the public surface of your projects

from m in Application.Methods
where m.IsPubliclyVisible &amp;&amp; 

     // The method has been removed and its parent project hasn'm been removed ...
     ( (m.WasAdded() &amp;&amp; !m.ParentType.WasAdded()) ||

     // ... or the t existed but was not publicly visible
       !m.WasAdded() &amp;&amp; !m.OlderVersion().IsPubliclyVisible)

select new { m,
             OldVisibility = (m.WasAdded() ? " " : m.OlderVersion().Visibility.ToString()) }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;API: New publicly visible fields&lt;/Name&gt;
// List fields that are new in the public surface of your projects

from f in Application.Fields
where f.IsPubliclyVisible &amp;&amp; 

     // The method has been removed and its parent project hasn'f been removed ...
     ( (f.WasAdded() &amp;&amp; !f.ParentType.WasAdded()) ||

     // ... or the t existed but was not publicly visible
       !f.WasAdded() &amp;&amp; !f.OlderVersion().IsPubliclyVisible)

select new { f,
             OldVisibility = (f.WasAdded() ? " " : f.OlderVersion().Visibility.ToString()) }</Query>
    </Group>
    <Group Active="False" Name="Code Diff Summary" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;New projects&lt;/Name&gt;
from a in Application.Projects where a.WasAdded()
select new { a, a.NbLinesOfCode }

</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Projects removed&lt;/Name&gt;
from a in codeBase.OlderVersion().Application.Projects where a.WasRemoved()
select new { a, a.NbLinesOfCode }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Projects where code was changed&lt;/Name&gt;
from a in Application.Projects where a.CodeWasChanged()
select new { a, a.NbLinesOfCode, 
             oldNbLinesOfCode = a.OlderVersion().NbLinesOfCode.GetValueOrDefault() ,
             delta = (int) a.NbLinesOfCode.GetValueOrDefault() - a.OlderVersion().NbLinesOfCode.GetValueOrDefault() }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;New packages&lt;/Name&gt;
from n in Application.Packages where 
 !n.ParentProject.WasAdded() &amp;&amp;
  n.WasAdded()
select new { n, n.NbLinesOfCode }
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Packages removed&lt;/Name&gt;
from n in codeBase.OlderVersion().Application.Packages where 
 !n.ParentProject.WasRemoved() &amp;&amp;
  n.WasRemoved()
select new { n, n.NbLinesOfCode }
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Packages where code was changed&lt;/Name&gt;
from n in Application.Packages where n.CodeWasChanged()
select new { n, n.NbLinesOfCode, 
             oldNbLinesOfCode = n.OlderVersion().NbLinesOfCode.GetValueOrDefault() ,
             delta = (int) n.NbLinesOfCode.GetValueOrDefault() - n.OlderVersion().NbLinesOfCode.GetValueOrDefault() }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;New types&lt;/Name&gt;
from t in Application.Types where 
 !t.ParentPackage.WasAdded() &amp;&amp;
  t.WasAdded()
select new { t, t.NbLinesOfCode }
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Types removed&lt;/Name&gt;
from t in codeBase.OlderVersion().Application.Types where 
 !t.ParentPackage.WasRemoved() &amp;&amp;
  t.WasRemoved()
select new { t, t.NbLinesOfCode }
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Types where code was changed&lt;/Name&gt;
// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file

from t in Application.Types where t.CodeWasChanged() 
//select new { t, t.NbLinesOfCode }
select new { t, t.NbLinesOfCode, 
             oldNbLinesOfCode = t.OlderVersion().NbLinesOfCode ,
             delta = (int?) t.NbLinesOfCode - t.OlderVersion().NbLinesOfCode } 
/*from t in Application.Types where t.CodeWasChanged() &amp;&amp; t.IsPresentInBothBuild
select new { t, t.NbLinesOfCode, 
             oldNbLinesOfCode = t.OlderVersion().NbLinesOfCode ,
             delta = (int) t.NbLinesOfCode - t.OlderVersion().NbLinesOfCode }*/</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Heuristic to find types moved from one package or project to another&lt;/Name&gt;
let typesRemoved = codeBase.OlderVersion().Types.Where(t =&gt; t.WasRemoved())
let typesAdded = Types.Where(t =&gt; t.WasAdded())

from tMoved in typesAdded.Join(
   typesRemoved,
   t =&gt; t.Name,
   t =&gt; t.Name,
   (tNewer, tOlder) =&gt; new { tNewer, 
                             OlderParentpackage = tOlder.ParentPackage,
                             OlderParentproject = tOlder.ParentProject  } ) 
select tMoved</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Types directly using one or several types changed&lt;/Name&gt;
let typesChanged = Application.Types.Where(t =&gt; t.CodeWasChanged()).ToHashSet()

from t in JustMyCode.Types.UsingAny(typesChanged) where
  !t.CodeWasChanged() &amp;&amp; 
  !t.WasAdded()
let typesChangedUsed = t.TypesUsed.Intersect(typesChanged) 
select new { t, typesChangedUsed }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Types indirectly using one or several types changed&lt;/Name&gt;
let typesChanged = Application.Types.Where(t =&gt; t.CodeWasChanged()).ToHashSet()

// 'depth' represents a code metric defined on types using
// directly or indirectly any type where code was changed.
let depth = JustMyCode.Types.DepthOfIsUsingAny(typesChanged) 

from t in depth.DefinitionDomain where
  !t.CodeWasChanged() &amp;&amp; 
  !t.WasAdded()

let typesChangedDirectlyUsed = t.TypesUsed.Intersect(typesChanged) 
let depthOfUsingTypesChanged = depth[t]
orderby depthOfUsingTypesChanged 

select new { t, depthOfUsingTypesChanged, typesChangedDirectlyUsed }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;New methods&lt;/Name&gt;
from m in Application.Methods where 
 !m.ParentType.WasAdded() &amp;&amp;
  m.WasAdded()
select new { m, m.NbLinesOfCode }
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Methods removed&lt;/Name&gt;
from m in codeBase.OlderVersion().Application.Methods where 
 !m.ParentType.WasRemoved() &amp;&amp;
  m.WasRemoved()
select new { m, m.NbLinesOfCode }
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Methods where code was changed&lt;/Name&gt;
// To visualize changes in code, right-click a matched method and select:
//  - Compare older and newer versions of source file


from m in Application.Methods where m.CodeWasChanged()
select new { m, m.NbLinesOfCode, 
             oldNbLinesOfCode = m.OlderVersion().NbLinesOfCode ,
             delta = (int?) m.NbLinesOfCode - m.OlderVersion().NbLinesOfCode }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Methods directly calling one or several methods changed&lt;/Name&gt;
let methodsChanged = Application.Methods.Where(m =&gt; m.CodeWasChanged()).ToHashSet()

from m in JustMyCode.Methods.UsingAny(methodsChanged ) where
  !m.CodeWasChanged() &amp;&amp; 
  !m.WasAdded()
let methodsChangedCalled = m.MethodsCalled.Intersect(methodsChanged) 
select new { m, methodsChangedCalled }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Methods indirectly calling one or several methods changed&lt;/Name&gt;
let methodsChanged = Application.Methods.Where(m =&gt; m.CodeWasChanged()).ToHashSet()

// 'depth' represents a code metric defined on methods using
// directly or indirectly any method where code was changed.
let depth = JustMyCode.Methods.DepthOfIsUsingAny(methodsChanged) 

from m in depth.DefinitionDomain where
  !m.CodeWasChanged() &amp;&amp; 
  !m.WasAdded()

let methodsChangedDirectlyUsed = m.MethodsCalled.Intersect(methodsChanged) 
let depthOfUsingMethodsChanged = depth[m]
orderby depthOfUsingMethodsChanged 

select new { m, depthOfUsingMethodsChanged, methodsChangedDirectlyUsed }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;New fields&lt;/Name&gt;
from f in Application.Fields where 
 !f.ParentType.WasAdded() &amp;&amp;
  f.WasAdded()
select new { f }
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Fields removed&lt;/Name&gt;
from f in codeBase.OlderVersion().Application.Fields where 
 !f.ParentType.WasRemoved() &amp;&amp;
  f.WasRemoved()
select new { f }
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="False" IsCriticalRule="False">// &lt;Name&gt;Third party types that were not used and that are now used&lt;/Name&gt;
from t in ThirdParty.Types where t.IsUsedRecently()
select new { t, t.Methods, t.Fields, t.TypesUsingMe }
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="False" IsCriticalRule="False">// &lt;Name&gt;Third party types that were used and that are not used anymore&lt;/Name&gt;
from t in codeBase.OlderVersion().Types where t.IsNotUsedAnymore()
select new { t, t.Methods, t.Fields, TypesThatUsedMe = t.TypesUsingMe }
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="False" IsCriticalRule="False">// &lt;Name&gt;Third party methods that were not used and that are now used&lt;/Name&gt;
from m in ThirdParty.Methods where 
  m.IsUsedRecently() &amp;&amp;
 !m.ParentType.IsUsedRecently()
select new { m, m.MethodsCallingMe }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="False" IsCriticalRule="False">// &lt;Name&gt;Third party methods that were used and that are not used anymore&lt;/Name&gt;
from m in codeBase.OlderVersion().Methods where 
  m.IsNotUsedAnymore() &amp;&amp;
 !m.ParentType.IsNotUsedAnymore()
select new { m, MethodsThatCalledMe = m.MethodsCallingMe}</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Third party fields that were not used and that are now used&lt;/Name&gt;
from f in ThirdParty.Fields where 
  f.IsUsedRecently() &amp;&amp;
 !f.ParentType.IsUsedRecently()
select new { f, f.MethodsUsingMe }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Third party fields that were used and that are not used anymore&lt;/Name&gt;
from f in codeBase.OlderVersion().Fields where 
  f.IsNotUsedAnymore() &amp;&amp;
 !f.ParentType.IsNotUsedAnymore()
select new { f, MethodsThatUsedMe = f.MethodsUsingMe }</Query>
    </Group>
    <Group Active="False" Name="Test and Code Coverage" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;C.R.A.P method code metric&lt;/Name&gt;
// Change Risk Analyzer and Predictor (i.e. CRAP) code metric
// This code metric helps in pinpointing overly complex and untested code.
// Reference: http://www.artima.com/weblogs/viewpost.jsp?thread=215899
// Formula:   CRAP(m) = comp(m)^2 * (1 &#8211; cov(m)/100)^3 + comp(m)
warnif count &gt; 0
from m in JustMyCode.Methods

// Don't match too short methods
where m.NbLinesOfCode &gt; 10

let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (CC * CC * uncov * uncov * uncov) + CC
where CRAP != null &amp;&amp; CRAP &gt; 30
orderby CRAP descending, m.NbLinesOfCode descending
select new { m, CRAP, CC, uncoveredPercentage = uncov*100, m.NbLinesOfCode }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Complex methods partially covered by tests should be 100% covered&lt;/Name&gt;
warnif count &gt; 0 from m in JustMyCode.Methods 
 where 
     // These metrics' definitions are available here: 
     // http://www.jarchitect.com/Metrics.aspx#MetricsOnMethods
     (  m.NbLinesOfCode &gt; 30 || 
        m.BCCyclomaticComplexity &gt; 50 || 
        m.BCNestingDepth &gt; 4 || 
        m.NbVariables &gt; 8) &amp;&amp; 

     // Take care only of complex methods 
     // already partially covered, but not completely covered.
     m.PercentageCoverage &gt; 0 &amp;&amp;
     m.PercentageCoverage &lt; 100

  orderby m.NbLinesOfCodeNotCovered ascending,
          m.NbLinesOfCode descending
select new { m, m.PercentageCoverage, m.NbLinesOfCode, 
             m.NbLinesOfCodeCovered, m.NbLinesOfCodeNotCovered, 
             m.BCCyclomaticComplexity, m.BCNestingDepth, m.NbVariables }  </Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Method changed poorly covered&lt;/Name&gt;
from m in Application.Methods where 
  m.PercentageCoverage &lt; 30 &amp;&amp; 
  m.CodeWasChanged() 
  orderby m.NbLinesOfCode descending, 
           m.NbLinesOfCodeNotCovered ,
           m.PercentageCoverage
select new { m, m.PercentageCoverage, m.NbLinesOfCode, 
             m.NbLinesOfCodeNotCovered }  
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Method added poorly covered&lt;/Name&gt;
from m in Application.Methods where
  m.NbLinesOfCode &gt; 0 &amp;&amp;
  m.PercentageCoverage &lt; 30 &amp;&amp; 
  m.WasAdded() 
  orderby m.NbLinesOfCode descending, 
           m.NbLinesOfCodeNotCovered ,
           m.PercentageCoverage
select new { m, m.PercentageCoverage, m.NbLinesOfCode, 
             m.NbLinesOfCodeNotCovered } 
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Types 95% to 99% covered&lt;/Name&gt;
from t in Application.Types where 
  t.PercentageCoverage &gt;= 95 &amp;&amp; 
  t.PercentageCoverage &lt;= 99 &amp;&amp;
 !t.IsGeneratedByCompiler

  let methodsCulprit = t.Methods.Where(m =&gt; m.PercentageCoverage &lt; 100)

  orderby t.NbLinesOfCode descending , 
           t.NbLinesOfCodeNotCovered ,
           t.PercentageCoverage
select new { t, t.PercentageCoverage, t.NbLinesOfCode, 
             t.NbLinesOfCodeNotCovered, methodsCulprit } 

// Having types 100% covered by tests is a good idea because 
// the small portion of code hard to cover, is also the 
// portion of code that is the most likely to contain bugs.
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Packages 95% to 99% covered&lt;/Name&gt;
from n in Application.Packages where 
  n.PercentageCoverage &gt;= 95 &amp;&amp; 
  n.PercentageCoverage &lt;= 99 

  let methodsCulprit = n.ChildMethods.Where(m =&gt; m.PercentageCoverage &lt; 100)

  orderby n.NbLinesOfCode descending , 
           n.NbLinesOfCodeNotCovered ,
           n.PercentageCoverage
select new { n, n.PercentageCoverage, n.NbLinesOfCode, 
             n.NbLinesOfCodeNotCovered, methodsCulprit  } 

// Having types 100% covered by tests is a good idea because 
// the small portion of code hard to cover, is also the 
// portion of code that is the most likely to contain bugs.</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Types not covered at all&lt;/Name&gt;
from t in Application.Types where 
  t.PercentageCoverage == 0
  orderby t.NbLinesOfCode descending
select new { t, t.NbLinesOfCode } 
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Packages not covered at all&lt;/Name&gt;
from n in Application.Packages where 
  n.PercentageCoverage == 0
  orderby n.NbLinesOfCode descending
select new { n, n.NbLinesOfCode} 
</Query>
    </Group>
    <Group Active="False" Name="Dead Code" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Potentially dead Types&lt;/Name&gt;
warnif count &gt; 0
// Filter procedure for types that should'nt be considered as dead
let canTypeBeConsideredAsDeadProc = new Func&lt;IType, bool&gt;(
   t =&gt; !t.IsPublic &amp;&amp; //   Public types might be used by client applications of your projects.
         t.Name != "Program" &amp;&amp; 
        !t.IsGeneratedByCompiler 
        )

// Select types unused
let typesUnused = 
   from t in JustMyCode.Types where
   t.NbTypesUsingMe == 0 &amp;&amp; canTypeBeConsideredAsDeadProc(t)
   select t

// Dead types = types used only by unused types (recursive)
let deadTypesMetric = typesUnused.FillIterative(
types =&gt; from t in codeBase.Application.Types.UsedByAny(types).Except(types)
         where canTypeBeConsideredAsDeadProc(t) &amp;&amp;
               t.TypesUsingMe.Intersect(types).Count() == t.NbTypesUsingMe
         select t)

from t in deadTypesMetric.DefinitionDomain
select new { t, t.TypesUsingMe, depth = deadTypesMetric[t] }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Potentially dead Methods&lt;/Name&gt;
warnif count &gt; 0
// Filter procedure for methods that should'nt be considered as dead
let canMethodBeConsideredAsDeadProc = new Func&lt;IMethod, bool&gt;(
    m =&gt; !m.IsPubliclyVisible &amp;&amp;       // Public methods might be used by client applications of your projects.
         !m.IsEntryPoint &amp;&amp;            // Main() method is not used by-design.
         !m.IsClassConstructor &amp;&amp;      // The BC code never explicitely calls class constructors.
         !(m.IsConstructor &amp;&amp;          // Don't take account of protected ctor that might be call by a derived ctors.
           m.IsProtected) &amp;&amp;
         !m.IsGeneratedByCompiler)

// Get methods unused
let methodsUnused = 
   from m in JustMyCode.Methods where 
   m.NbMethodsCallingMe == 0 &amp;&amp; 
   canMethodBeConsideredAsDeadProc(m)
   select m

// Dead methods = methods used only by unused methods (recursive)
let deadMethodsMetric = methodsUnused.FillIterative(
   methods =&gt; // Unique loop, just to let a chance to build the hashset.
              from o in (new object()).ToEnumerable()
              // Use a hashet to make Intersect calls much faster!
              let hashset = methods.ToHashSet()
              from m in codeBase.Application.Methods.UsedByAny(methods).Except(methods)
              where canMethodBeConsideredAsDeadProc(m) &amp;&amp;
                    // Select methods called only by methods already considered as dead
                    hashset.Intersect(m.MethodsCallingMe).Count() == m.NbMethodsCallingMe
              select m)

from m in JustMyCode.Methods.Intersect(deadMethodsMetric.DefinitionDomain)
select new { m, m.MethodsCallingMe, depth = deadMethodsMetric[m] }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Potentially dead Fields&lt;/Name&gt;
warnif count &gt; 0
from f in JustMyCode.Fields where
   f.NbMethodsUsingMe == 0 &amp;&amp; 
   !f.IsPublic &amp;&amp;     // Although not recommended, public fields might be used by client applications of your projects.
   !f.IsLiteral &amp;&amp;    // The BC code never explicitely uses literal fields.
   !f.IsEnumValue  &amp;&amp; // The BC code never explicitely uses enumeration value.
   f.Name!= "serialVersionUID" &amp;&amp;
   !f.IsInitOnly

   
select f</Query>
    </Group>
    <Group Active="False" Name="Visibility" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Methods that could have a lower visibility&lt;/Name&gt;
warnif count &gt; 0 from m in JustMyCode.Methods where 
  m.Visibility != m.OptimalVisibility &amp;&amp;
  // Eliminate default constructor from the result.
  // Whatever the visibility of the declaring class,
  // default constructors are public and introduce noise
  // in the current rule.
  !( m.IsConstructor &amp;&amp; m.IsPublic &amp;&amp; m.NbParameters == 0) &amp;&amp;

  // Don't decrease the visibility of Main() methods.
  !m.IsEntryPoint

select new { m, 
             m.Visibility , 
             CouldBeDeclared = m.OptimalVisibility,
             m.MethodsCallingMe }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Fields that could have a lower visibility&lt;/Name&gt;
warnif count &gt; 0 from f in JustMyCode.Fields where 
  f.Visibility != f.OptimalVisibility
  
  select new { f, 
             f.Visibility , 
             CouldBeDeclared = f.OptimalVisibility,
             f.MethodsUsingMe }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Fields should be declared as private&lt;/Name&gt;
warnif count &gt; 0 from f in Application.Fields where 
 !f.IsPrivate &amp;&amp; 

 // These conditions filter cases where fields 
 // doesn't represent state that should be encapsulated. 
 !f.IsGeneratedByCompiler &amp;&amp; 
  !f.IsInitOnly &amp;&amp; 
 !f.IsLiteral &amp;&amp; 
 !f.IsEnumValue
select new { f, f.SizeOfInst }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Constructors of abstract classes should be declared as protected or private&lt;/Name&gt;
// Constructors of an abstract class can only be accessed from this class and derived class.
// Declaring such a constructor with another visibility level is useless and potentially misleading.

warnif count &gt; 0
from t in Application.Types where 
  t.IsClass &amp;&amp; 
  t.IsAbstract
let ctors = t.Constructors.Where(c =&gt; !c.IsProtected &amp;&amp; !c.IsPrivate)
where ctors.Count() &gt; 0
select new { t, ctors }

// Notice that if a constructor of an abstract class is declared as private,
// it can only be accessed from derived classes nested in the abstract class.</Query>
    </Group>
    <Group Active="False" Name="Purity - Immutability - Side-Effects" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Fields should be marked as ReadOnly when possible&lt;/Name&gt;
warnif count &gt; 0 
from f in JustMyCode.Fields where 
   f.IsImmutable &amp;&amp; 
  !f.IsInitOnly &amp;&amp;
  !f.IsGeneratedByCompiler 
select new { f, f.SizeOfInst } 

// A field that matches the condition IsImmutable 
// is a field that is assigned only by constructors 
// of its class.
// For an instance field, this means its value 
// will remain constant throught the lifetime 
// of the object.
// For a static field, this means its value will 
// remain constant throught the lifetime of the 
// program.
// In both cases, such field can safely be marked 



</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Property Getters should be immutable&lt;/Name&gt;
warnif count &gt; 0 from m in Application.Methods where
  m.IsPropertyGetter &amp;&amp;
  ( ( !m.IsStatic &amp;&amp; m.ChangesObjectState) ||
    (  m.IsStatic &amp;&amp; m.ChangesTypeState) )

let fieldsAssigned = m.FieldsAssigned

select new { m, m.NbLinesOfCode, fieldsAssigned  }

// This rule might be violated in the case of object lazy initialized
// when the property getter is accessed the first time.
// But in general, the callers of a property 
// doesn't expect to change any state through the call.
    </Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid static fields with a mutable field type&lt;/Name&gt;
warnif count &gt; 0
from f in Application.Fields
where f.IsStatic &amp;&amp; !f.IsEnumValue &amp;&amp; !f.IsGeneratedByCompiler &amp;&amp; !f.IsLiteral
let fieldType = f.FieldType
where fieldType != null &amp;&amp; 
     !fieldType.IsThirdParty &amp;&amp; 
     !fieldType.IsInterface &amp;&amp; 
     !fieldType.IsImmutable
select new { f, 
             mutableFieldType = fieldType , 
             isFieldImmutable = f.IsImmutable, 
             isFieldIsReadOnly = f.IsInitOnly }


// static fields should be used to hold only constant and immutable states.
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;A field must not be assigned from outside its parent hierarchy types&lt;/Name&gt;
warnif count &gt; 0
from f in JustMyCode.Fields.Where(f =&gt; 
      !f.IsPrivate &amp;&amp; !f.IsGeneratedByCompiler &amp;&amp; 
      !f.IsImmutable &amp;&amp; !f.IsEnumValue)

let methodsAssignerOutsideOfMyType = f.MethodsAssigningMe.Where(
        m =&gt;!m.IsGeneratedByCompiler &amp;&amp;
             m.ParentType != f.ParentType &amp;&amp; 
            !m.ParentType.DeriveFrom(f.ParentType) )

where methodsAssignerOutsideOfMyType.Count() &gt; 0
select new { f, methodsAssignerOutsideOfMyType }</Query>
    </Group>
    <Group Active="False" Name="Naming Conventions" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Instance fields should begin with a lower character &lt;/Name&gt;
warnif count &gt; 0 from f in Application.Fields where 
  !f.NameLike (@"^[a-z]")  &amp;&amp; 
  !f.IsStatic &amp;&amp; 
  !f.IsLiteral &amp;&amp; 
  !f.IsGeneratedByCompiler 
select new { f, f.SizeOfInst } 

// This naming convention provokes debate.
// Don't hesitate to customize the regex of 
// NameLike to your preference.</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Interface name should begin with an Upper character&lt;/Name&gt;
warnif count &gt; 0 from t in Application.Types where 
t.IsInterface  &amp;&amp;
!t.SimpleNameLike (@"^[A-Z]")
select t
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Exception class name should be suffixed with 'Exception'&lt;/Name&gt;
warnif count &gt; 0 from t in Application.Types where 
  t.IsExceptionClass &amp;&amp; 
  !t.NameLike (@"Exception$")
select new { t, t.NbLinesOfCode }

// The name of an exception class should end with 'Exception'.</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Types name should begin with an Upper character&lt;/Name&gt;
warnif count &gt; 0 from t in JustMyCode.Types where 
  // The name of a type should begin with an Upper letter.
  !t.SimpleNameLike (@"^[A-Z]") &amp;&amp;     

  // Except if it is generated by compiler or ...
  
  !t.IsGeneratedByCompiler


select new { t, t.NbLinesOfCode }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Methods name should begin with an lower character&lt;/Name&gt;
warnif count &gt; 0 from m in JustMyCode.Methods where 
  !m.NameLike (@"^[a-z]") &amp;&amp; 
  
  !m.IsGeneratedByCompiler &amp;&amp; !m.IsConstructor
select m

// The name of a regular method should 
// begin with an Upper letter.</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid types with name too long&lt;/Name&gt;
warnif count &gt; 0 from t in Application.Types 
where !t.IsGeneratedByCompiler

where t.SimpleName.Length &gt; 35 
select new { t, t.SimpleName }

      </Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid methods with name too long&lt;/Name&gt;
warnif count &gt; 0 from m in Application.Methods where 
  !m.IsGeneratedByCompiler &amp;&amp;
 m.SimpleName.Length &gt; 35

select new { m, m.SimpleName }

// The regex matches methods with name longer 
// than 35 characters.
// Method Name doesn't contain the type and package 
// prefix, FullName does.
// The regex computes the method name length from 
// the beginning until the first open parenthesis 
// or first lower than (for generic methods).
// Explicit Interface Implementation methods are 
// discarded because their names are prefixed 
// with the interface name.
      </Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid fields with name too long&lt;/Name&gt;
warnif count &gt; 0 from f in Application.Fields where
 !f.IsGeneratedByCompiler &amp;&amp;
  f.Name.Length &gt; 35
select f

// The regex matches fields with name longer 
// than 35 characters.
// Field Name doesn't contain the type and 
// package prefix, FullName does.
      </Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False"> // &lt;Name&gt;Avoid having different types with same name&lt;/Name&gt;
// Such practice typically creates confusion, 
// and type naming collision inside a source file.

warnif count &gt; 0

// This rule matches also collisions between 
// application and third-party types sharing a same name.
let groups = JustMyCode.Types.Union(ThirdParty.Types)
                 // Discard nested types, whose name is 
                 // prefixed with the parent type name.
                 .Where(t =&gt; !t.IsNested)
                 
                 // Group types by name.
                 .GroupBy(t =&gt; t.Name)

from @group in groups 
   where @group.Count() &gt; 1

   // Let's see if types with the same name are declared
   // in different packages.
   // (t.FullName is {packageName}.{typeName} )
   let groupsFullName = @group.GroupBy(t =&gt; t.FullName)
   where groupsFullName.Count() &gt; 1

   // If several types with same name are declared in different packages
   // eliminate the case where all types are declared in third-party projects.
   let types= groupsFullName.SelectMany(g =&gt; g)
   where types.Any(t =&gt; !t.IsThirdParty)
        // Uncomment this line, to only gets naming collision involving
        // both application adn third-party types.
        //         &amp;&amp; types.Any(t =&gt; t.IsThirdParty)

orderby types.Count() descending 

select new { t = types.First(),
             // In the 'types' column, make sure to group matched types 
             // by parent projects and parent packages.
             types
            }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid prefixing type name with parent package name&lt;/Name&gt;

// For example a type named "RuntimeEnvironment"
// declared in a package named "Foo.Runtime"
// should be named "Environment"

from n in Application.Packages where n.Name.Length &gt; 0
from t in n.ChildTypes
where 
 !t.IsGeneratedByCompiler &amp;&amp;
 !t.IsNested &amp;&amp;
  t.Name.IndexOf(n.SimpleName) == 0
select new { t, packageName = n.SimpleName }</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Avoid naming types and packages with the same identifier&lt;/Name&gt;

// Not only this can provoke compiler resolution collision,
// but also, this makes code less maintainable because
// concepts are not concisely identified.

warnif count &gt; 0
let hashsetShortNames = Packages.Where(n =&gt; n.Name.Length &gt; 0).Select(n =&gt; n.SimpleName).ToHashSet()

from t in JustMyCode.Types
where hashsetShortNames.Contains(t.Name)
select new { t, packages = Packages.Where(n =&gt; n.SimpleName == t.Name) }</Query>
    </Group>
    <Group Active="False" Name="Trend Metrics" ShownInReport="False">
      <Group Active="True" Name="Code Size" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Lines of Code" Unit="LoC" /&gt;  
Application.Projects.Sum(a =&gt; a.NbLinesOfCode)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Lines of Code (JustMyCode)" Unit="LoC" /&gt;
JustMyCode.Methods.Sum(m =&gt; m.NbLinesOfCode)

// JustMyCode is defined by code queries prefixed with 'notmycode' 
// in the group 'Defining JustMyCode'.
</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Lines of Code (NotMyCode)" Unit="LoC" /&gt;
Application.Methods.Where(m =&gt; !JustMyCode.Contains(m))
                   .Sum(m =&gt; m.NbLinesOfCode)

// JustMyCode is defined by code queries prefixed with 'notmycode' 
// in the group 'Defining JustMyCode'.
</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Lines of Code Added since the Baseline" Unit="LoC" /&gt;  
( from a in Application.Projects
  let nbLocAdded = a.IsPresentInBothBuilds() ? 
                   a.NbLinesOfCode - (int)a.OlderVersion().NbLinesOfCode :
                   a.NbLinesOfCode
  select nbLocAdded)
.Sum(loc =&gt; loc)

// A value is computed by this Trend Metric query
// only if a Baseline for Comparison is provided.
// See Project Properties &gt; Analysis &gt; Baseline for Comparison
</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# BC Instructions" Unit="BC Instructions" /&gt;
Application.Projects.Sum(a =&gt; a.NbBCInstructions)
</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# BC Instructions (NotMyCode)" Unit="BC Instructions" /&gt;
Application.Methods.Where(m =&gt; !JustMyCode.Contains(m))
                   .Sum(m =&gt; m.NbBCInstructions)

// JustMyCode is defined by code queries prefixed with 'notmycode' 
// in the group 'Defining JustMyCode'.
</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Source Files" Unit="Source Files" /&gt;
Application.Projects.SelectMany(
  a =&gt; a.SourceDecls.Select(sd =&gt; sd.SourceFile.FilePathString.ToLower()))
.Distinct()
.Count()

</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Lines of Comments" Unit="Lines" /&gt;  
Application.Projects.Sum(a =&gt; a.NbLinesOfComment)


</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Projects" Unit="Projects" /&gt;
Application.Projects.Count()

</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Packages" Unit="PACKAGES" /&gt;
Application.Packages.Count()</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Types" Unit="Types" /&gt;
Application.Types.Count()</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Public Types" Unit="Types" /&gt;
Application.Types.Where(t =&gt; t.IsPubliclyVisible).Count()</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Classes" Unit="Types" /&gt;
Application.Types.Count(t =&gt; t.IsClass &amp;&amp; !t.IsGeneratedByCompiler)
</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Abstract Classes" Unit="Types" /&gt;
Application.Types.Count(t =&gt; t.IsClass &amp;&amp; t.IsAbstract)

</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Interfaces" Unit="Types" /&gt;
Application.Types.Count(t =&gt; t.IsInterface)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Methods" Unit="Methods" /&gt;
Application.Methods.Count(m =&gt; !m.IsGeneratedByCompiler)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Abstract Methods" Unit="Methods" /&gt;
Application.Methods.Count(m =&gt; m.IsAbstract)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Concrete Methods" Unit="Methods" /&gt;
Application.Methods.Count(m =&gt; !m.IsAbstract &amp;&amp; !m.IsGeneratedByCompiler)
</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Fields" Unit="Fields" /&gt;
Application.Fields.Count(f =&gt; 
   !f.IsEnumValue &amp;&amp; 
   !f.IsGeneratedByCompiler &amp;&amp; 
   !f.IsLiteral &amp;&amp;
   !f.ParentType.IsEnumeration)

</Query>
      </Group>
      <Group Active="True" Name="Maximum and Average" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="Max # Lines of Code for Methods (JustMyCode)" Unit="LoC" /&gt;
JustMyCode.Methods
          .Max(m =&gt; m.NbLinesOfCode)
          .ToEnumerable().Sum(loc =&gt; loc)

// Here is the code query to get the (JustMyCode) method with largest # Lines of Code
// JustMyCode.Methods.OrderByDescending(m =&gt; m.NbLinesOfCode).Take(1).Select(m =&gt; new {m, m.NbLinesOfCode})
</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="Average # Lines of Code for Methods" Unit="LoC" /&gt;
Application.Methods.Where(m =&gt; m.NbLinesOfCode &gt; 0)
                   .Average(m =&gt; m.NbLinesOfCode)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="Average # Lines of Code for Methods with at least 3 Lines of Code" Unit="LoC" /&gt;
Application.Methods.Where(m =&gt; m.NbLinesOfCode &gt;= 3)
                   .Average(m =&gt; m.NbLinesOfCode)
</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="Max # Lines of Code for Types (JustMyCode)" Unit="LoC" /&gt;
JustMyCode.Types
          .Max(t =&gt; t.NbLinesOfCode)
          .ToEnumerable().Sum(loc =&gt; loc)

// Here is the code query to get the (JustMyCode) type with largest # Lines of Code
// JustMyCode.Types.OrderByDescending(t =&gt; t.NbLinesOfCode).Take(1).Select(t =&gt; new {t, t.NbLinesOfCode})

</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="Average # Lines of Code for Types" Unit="LoC" /&gt;
Application.Types.Where(t =&gt; t.NbLinesOfCode &gt; 0)
                 .Average(t =&gt; t.NbLinesOfCode)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="Max Cyclomatic Complexity for Methods" Unit="Paths" /&gt;
Application.Methods
          .Max(m =&gt; m.CyclomaticComplexity)
          .ToEnumerable().Sum(loc =&gt; loc)

// Here is the code query to get the most complex method, according to Cyclomatic Complexity
// Application.Methods.OrderByDescending(m =&gt; m.CyclomaticComplexity).Take(1).Select(m =&gt; new {m, m.CyclomaticComplexity})
</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="Average Cyclomatic Complexity for Methods" Unit="Paths" /&gt;
Application.Methods.Where(m =&gt; m.NbLinesOfCode&gt; 0)
                   .Average(m =&gt; m.CyclomaticComplexity)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="Max BC Cyclomatic Complexity for Methods" Unit="Paths" /&gt;
Application.Methods
          .Max(m =&gt; m.BCCyclomaticComplexity)
          .ToEnumerable().Sum(loc =&gt; loc)

// Here is the code query to get the most complex method, according to Cyclomatic Complexity computed from IL code.
// Application.Methods.OrderByDescending(m =&gt; m.BCCyclomaticComplexity).Take(1).Select(m =&gt; new {m, m.CyclomaticComplexity})
</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="Average BC Cyclomatic Complexity for Methods" Unit="Paths" /&gt;
Application.Methods.Where(m =&gt; m.NbBCInstructions&gt; 0)
                   .Average(m =&gt; m.BCCyclomaticComplexity)
</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="Max BC Nesting Depth for Methods" Unit="Scopes" /&gt;
Application.Methods
          .Max(m =&gt; m.BCNestingDepth)
          .ToEnumerable().Sum(loc =&gt; loc)

// Here is the code query to get the method with highest BCNestingDepth.
// Application.Methods.OrderByDescending(m =&gt; m.BCNestingDepth).Take(1).Select(m =&gt; new {m, m.BCNestingDepth})
</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="Average BC Nesting Depth for Methods" Unit="Scopes" /&gt;
Application.Methods.Where(m =&gt; m.NbBCInstructions&gt; 0)
                   .Average(m =&gt; m.BCNestingDepth)
</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="Max # of Methods for Types" Unit="Methods" /&gt;
Application.Types
           .Max(t =&gt; t.NbMethods) 
           .ToEnumerable().Sum(loc =&gt; loc)

// Here is the code query to get the (JustMyCode) type with largest # of Methods
// JustMyCode.Types.OrderByDescending(t =&gt; t.NbMethods).Take(1).Select(t =&gt; new {t, t.Methods})

</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="Average # Methods for Types" Unit="Methods" /&gt;
Application.Types.Average(t =&gt; t.NbMethods)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="Max # of Methods for Interfaces" Unit="Methods" /&gt;
Application.Types.Where(t =&gt; t.IsInterface)
           .Max(t =&gt; t.NbMethods) 
           .ToEnumerable().Sum(loc =&gt; loc)

// Here is the code query to get the (JustMyCode) type with largest # of Methods
// JustMyCode.Types.OrderByDescending(t =&gt; t.NbMethods).Take(1).Select(t =&gt; new {t, t.Methods})</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="Average # Methods for Interfaces" Unit="Methods" /&gt;
JustMyCode.Types.Where(t =&gt; t.IsInterface)
                .Average(t =&gt; t.NbMethods)
</Query>
      </Group>
      <Group Active="True" Name="Code Coverage" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="Percentage Code Coverage" Unit="%" /&gt;
((float)Application.Projects.Sum(a =&gt; a.NbLinesOfCodeCovered) /
        Application.Projects.Sum(a =&gt; a.NbLinesOfCode)
 * 100f)
.ToEnumerable().Sum()
</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Lines of Code Covered" Unit="LoC" /&gt;
Application.Projects.Sum(a =&gt; a.NbLinesOfCodeCovered)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Lines of Code Not Covered" Unit="LoC" /&gt;
Application.Projects.Sum(a =&gt; a.NbLinesOfCodeNotCovered)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Lines of Code in Types 100% Covered" Unit="LoC" /&gt;
Application.Types.Where(t =&gt; t.PercentageCoverage == 100)
           .Sum(t =&gt; t.NbLinesOfCodeCovered)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Lines of Code in Methods 100% Covered" Unit="LoC" /&gt;
Application.Methods.Where(m =&gt; m.PercentageCoverage == 100)
           .Sum(m =&gt; m.NbLinesOfCodeCovered)</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="Max C.R.A.P Score" /&gt;
// Change Risk Analyzer and Predictor (i.e. CRAP) code metric
// This code metric helps in pinpointing overly complex and untested code.
// Reference: http://www.artima.com/weblogs/viewpost.jsp?thread=215899
// Formula:   CRAP(m) = comp(m)^2 * (1 - cov(m)/100)^3 + comp(m)

(from m in JustMyCode.Methods

// Don't match too short methods
where m.NbLinesOfCode &gt; 10

let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (CC * CC * uncov * uncov * uncov) + CC
where CRAP != null &amp;&amp; CRAP &gt; 30 select CRAP)
.Max(CRAP =&gt; CRAP)

// To list methods with highest C.R.A.P scores, please refer to the default rule:
//   Test and Code Coverage &gt; C.R.A.P method code metric
</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="Average C.R.A.P Score" /&gt;
// Change Risk Analyzer and Predictor (i.e. CRAP) code metric
// This code metric helps in pinpointing overly complex and untested code.
// Reference: http://www.artima.com/weblogs/viewpost.jsp?thread=215899
// Formula:   CRAP(m) = comp(m)^2 * (1 - cov(m)/100)^3 + comp(m)

(from m in JustMyCode.Methods

// Don't match too short methods
where m.NbLinesOfCode &gt; 10

let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (CC * CC * uncov * uncov * uncov) + CC
where CRAP != null &amp;&amp; CRAP &gt; 30 select CRAP)
.Average(CRAP =&gt; CRAP)

// To list methods with highest C.R.A.P scores, please refer to the default rule:
//   Test and Code Coverage &gt; C.R.A.P method code metric
</Query>
      </Group>
      <Group Active="True" Name="Third-Party Usage" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Third-Party Projects Used" Unit="Projects" /&gt;
ThirdParty.Projects.Count()</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Third-Party Packages Used" Unit="Packages" /&gt;
ThirdParty.Packages.Count()</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Third-Party Types Used" Unit="Types" /&gt;
ThirdParty.Types.Count()</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Third-Party Methods Used" Unit="Methods" /&gt;
ThirdParty.Methods.Count()</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;TrendMetric Name="# Third-Party Fields Used" Unit="Fields" /&gt;
ThirdParty.Fields.Count()</Query>
      </Group>
    </Group>
    <Group Active="False" Name="Defining JustMyCode" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Discard methods in a directory  from JustMyCode&lt;/Name&gt;
notmycode from m in Methods.Where(a=&gt;a.SourceDecls.FirstOrDefault()!=null &amp;&amp; a.SourceDecls.FirstOrDefault().SourceFile.DirectoryPath.Contains("path to exclude"))
select m

</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Discard types in a directory  from JustMyCode&lt;/Name&gt;
notmycode from t in Types.Where(a=&gt;a.SourceDecls.FirstOrDefault()!=null &amp;&amp; a.SourceDecls.FirstOrDefault().SourceFile.DirectoryPath.Contains("path to exclude"))
select t

</Query>
    </Group>
    <Group Active="False" Name="Statistics" ShownInReport="False">
      <Query Active="True" DisplayList="False" DisplaySelectionView="False" DisplayStat="False" IsCriticalRule="False">// &lt;Name&gt;Most used types (Rank)&lt;/Name&gt;
(from t in Application.Types orderby t.Rank descending
 select new { t, t.Rank }).Take(50)

// TypeRank values are computed by applying 
// the Google PageRank  algorithm on the 
// graph of types' dependencies. Types with 
// high Rank are the most used ones.
// See the definition of the TypeRank metric here: 
// http://www.jarchitect.com/Metrics.aspx#TypeRank</Query>
      <Query Active="True" DisplayList="False" DisplaySelectionView="False" DisplayStat="False" IsCriticalRule="False">// &lt;Name&gt;Most used methods (Rank)&lt;/Name&gt;
(from m in Application.Methods orderby m.Rank descending
 select new { m, m.Rank }).Take(50)

// MethodRank values are computed by applying 
// the Google PageRank  algorithm on the graph of 
// methods' dependencies. Methods with high Rank 
// are the most used ones. See the definition of 
// the MethodRank metric here:
// http://www.jarchitect.com/Metrics.aspx#MethodRank</Query>
      <Query Active="True" DisplayList="False" DisplaySelectionView="False" DisplayStat="False" IsCriticalRule="False">// &lt;Name&gt;Most used packages (#PackagesUsingMe )&lt;/Name&gt;
(from n in Packages orderby n.NbPackagesUsingMe descending
 select new { n, n.PackagesUsingMe }).Take(50)</Query>
      <Query Active="True" DisplayList="False" DisplaySelectionView="False" DisplayStat="False" IsCriticalRule="False">// &lt;Name&gt;Most used types (#TypesUsingMe )&lt;/Name&gt;
(from t in Types orderby t.NbTypesUsingMe descending
 select new { t, t.TypesUsingMe }).Take(50)</Query>
      <Query Active="True" DisplayList="False" DisplaySelectionView="False" DisplayStat="False" IsCriticalRule="False">// &lt;Name&gt;Most used methods (#MethodsCallingMe )&lt;/Name&gt;
(from m in Methods orderby m.NbMethodsCallingMe descending
 select new { m, m.MethodsCallingMe }).Take(50)</Query>
      <Query Active="True" DisplayList="False" DisplaySelectionView="False" DisplayStat="False" IsCriticalRule="False">// &lt;Name&gt;Packages that use many other packages (#PackagesUsed )&lt;/Name&gt;
(from n in Application.Packages orderby n.NbPackagesUsed descending
 select new { n, n.PackagesUsed }).Take(50)</Query>
      <Query Active="True" DisplayList="False" DisplaySelectionView="False" DisplayStat="False" IsCriticalRule="False">// &lt;Name&gt;Types that use many other types (#TypesUsed )&lt;/Name&gt;
(from t in Application.Types orderby t.NbTypesUsed descending
 select new { t, t.TypesUsed }).Take(50)</Query>
      <Query Active="True" DisplayList="False" DisplaySelectionView="False" DisplayStat="False" IsCriticalRule="False">// &lt;Name&gt;Methods that use many other methods (#MethodsCalled )&lt;/Name&gt;
(from m in Application.Methods orderby m.NbMethodsCalled descending
 select new { m, m.MethodsCalled }).Take(50)</Query>
      <Query Active="True" DisplayList="False" DisplaySelectionView="False" DisplayStat="False" IsCriticalRule="False">// &lt;Name&gt;High-level to low-level projects (Level)&lt;/Name&gt;
from a in Application.Projects orderby a.Level descending
select new { a, a.Level }

// Classify projects by their Level values.
// See the definition of the ProjectLevel metric here:
// http://www.jarchitect.com/Metrics.aspx#Level</Query>
      <Query Active="True" DisplayList="False" DisplaySelectionView="False" DisplayStat="False" IsCriticalRule="False">// &lt;Name&gt;High-level to low-level packages (Level)&lt;/Name&gt;
from n in Application.Packages orderby n.Level descending
select new { n, n.Level }

// Classify packages by their Level values.
// See the definition of the PackageLevel metric here:
// http://www.jarchitect.com/Metrics.aspx#Level</Query>
      <Query Active="True" DisplayList="False" DisplaySelectionView="False" DisplayStat="False" IsCriticalRule="False">// &lt;Name&gt;High-level to low-level types (Level)&lt;/Name&gt;
from t in Application.Types orderby t.Level descending
select new { t, t.Level }

// Classify types by their Level values.
// See the definition of the TypeLevel metric here:
// http://www.jarchitect.com/Metrics.aspx#Level</Query>
      <Query Active="True" DisplayList="False" DisplaySelectionView="False" DisplayStat="False" IsCriticalRule="False">// &lt;Name&gt;High-level to low-level methods (Level)&lt;/Name&gt;
from m in Application.Methods orderby m.Level descending
select new { m, m.Level }

// Classify methods by their Level values.
// See the definition of the MethodLevel metric here:
// http://www.jarchitect.com/Metrics.aspx#Level</Query>
    </Group>
    <Group Active="False" Name="Samples of Custom rules" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Check that the project Prj1 is not using the project Prj2&lt;/Name&gt;
warnif count &gt; 0 from a in Application.Projects where 
  a.IsUsing ("Prj2".AllowNoMatch().MatchProject()) &amp;&amp;
  (a.Name == @"Prj1")
select a
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Check that the package N1.N2 is not using the package N3.N4.N5&lt;/Name&gt;
warnif count &gt; 0 from n in Application.Packages where 
  n.IsUsing ("N3.N4.N5".AllowNoMatch().MatchProject()) &amp;&amp;
  (n.Name == @"N1.N2")
select n
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Check that the project Prj1 is only using the projects Prj2, Prj3&lt;/Name&gt;
warnif count &gt; 0 from a in Application.Projects where 
  ( !a.IsUsing ("Prj2".AllowNoMatch().MatchProject()) ||
    !a.IsUsing ("Prj3".AllowNoMatch().MatchProject()) ||
     a.ProjectsUsed.Count() != 3) // Must not be used more than 3 projects 
&amp;&amp; 
  (a.Name == @"Prj1")
select new { a, a.ProjectsUsed }
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Check that all methods that call Foo.Fct1() also call Foo.Fct2(Int32)&lt;/Name&gt;
warnif count &gt; 0 from m in Application.Methods where 
   m.IsUsing ("Foo.Fct1()".AllowNoMatch()) &amp;&amp;
  !m.IsUsing ("Foo.Fct2(Int32)".AllowNoMatch())
select m
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Check that all types that derive from Foo, also implement IFoo&lt;/Name&gt;
warnif count &gt; 0 from t in Application.Types where 
   t.DeriveFrom ("Foo".AllowNoMatch().MatchType()) &amp;&amp;
  !t.Implement ("IFoo".AllowNoMatch().MatchType())
select t
</Query>
      <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Check that all types that has the attribute FooAttribute are declared in the package N1.N2*&lt;/Name&gt;
warnif count &gt; 0 from t in 
  Application.Packages.WithNameWildcardMatchNotIn("N1.N2*").ChildTypes() 
  where 
    t.HasAnnotation ("FooAttribute".AllowNoMatch())
select t</Query>
      <Group Active="False" Name="Check Coverage on particular Code Elements" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Check that the project Asm is 100% covered by tests&lt;/Name&gt;
warnif count &gt; 0 from a in Application.Projects where 
  (a.Name == @"Asm") &amp;&amp; 
   a.PercentageCoverage &lt; 100
select new { a, a.PercentageCoverage }


// To run this rule properly coverage data 
// must be gathered from Cobertura
// This can be done throught the menu: 
//   JArchitect -&gt; Coverage -&gt; Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -&gt; Analysis -&gt; Code Coverage
// More information on how to import coverage data here:
// http://www.jarchitect.com/Coverage.aspx

</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Check that the package N1.N2 is 100% covered by tests&lt;/Name&gt;
warnif count &gt; 0 from n in Application.Packages where 
  (n.Name == @"N1.N2") &amp;&amp; 
   n.PercentageCoverage &lt; 100
select new { n, n.PercentageCoverage }


// To run this rule properly coverage data 
// must be gathered from Cobertura
// This can be done throught the menu: 
//   JArchitect -&gt; Coverage -&gt; Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -&gt; Analysis -&gt; Code Coverage
// More information on how to import coverage data here:
// http://www.jarchitect.com/Coverage.aspx

</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Check that the class package.Foo is 100% covered by tests&lt;/Name&gt;
warnif count &gt; 0 from t in Application.Types where 
  (t.FullName == @"package.Foo") &amp;&amp; 
   t.PercentageCoverage &lt; 100
select new { t, t.PercentageCoverage }


// To run this rule properly coverage data 
// must be gathered from Cobertura
// This can be done throught the menu: 
//   JArchitect -&gt; Coverage -&gt; Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -&gt; Analysis -&gt; Code Coverage
// More information on how to import coverage data here:
// http://www.jarchitect.com/Coverage.aspx

</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Check that the class package.Foo.Method(Int32) is 100% covered by tests&lt;/Name&gt;
warnif count &gt; 0 from t in Application.Types where 
  (t.FullName == @"package.Foo.Method(Int32)") &amp;&amp; 
   t.PercentageCoverage &lt; 100
select new { t, t.PercentageCoverage }


// To run this rule properly coverage data 
// must be gathered from Cobertura
// This can be done throught the menu: 
//   JArchitect -&gt; Coverage -&gt; Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -&gt; Analysis -&gt; Code Coverage
// More information on how to import coverage data here:
// http://www.jarchitect.com/Coverage.aspx

</Query>
      </Group>
      <Group Active="False" Name="Custom Naming Conventions" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Check that all types that derive from Foo, has a name that ends up with Foo&lt;/Name&gt;
warnif count &gt; 0 from t in Application.Types where 
   t.DeriveFrom ("Foo".AllowNoMatch().MatchType()) &amp;&amp;
  !t.NameLike (@"Foo$")
select new { t, t.NbLinesOfCode }
</Query>
        <Query Active="True" DisplayList="True" DisplaySelectionView="False" DisplayStat="True" IsCriticalRule="False">// &lt;Name&gt;Check that all packages begins with CompanyName.ProductName&lt;/Name&gt;
warnif count &gt; 0 from n in Application.Packages where 
  !n.NameLike (@"^CompanyName.ProductName")
select new { n, n.NbLinesOfCode } </Query>
      </Group>
    </Group>
    <Group Active="True" Name="New Group #0" ShownInReport="False" />
  </Queries><WarnFilter>
    <DontWarn>No classes founds for project:junit under output directory:C:\Users\User\workspace\Asig\target\classes; please check if the project was built</DontWarn>
    <DontWarn>Source code info won't be available : Some code metrics like CyclomaticComplexity,Comments,NBLineofCode won't be available.
Source files directories could be added in the project properties panel</DontWarn>
  </WarnFilter></NDepend>